// === DEBUG INSTRUMENTATION v3 ===
window.ENABLE_OUTPUTS = { text: true, documents: true, archives: true, spreadsheets: true, images: true, media: true };
const groupsOrder = ['text', 'documents', 'archives', 'spreadsheets', 'images', 'media'];

window.DEBUG_CONVERTER ??= false;  // set true only when you want verbose console diagnostics
window.QUIET_TECH ??= true;
function DBG() { try { if (window.DEBUG_CONVERTER) console.log.apply(console, arguments); } catch (e) { } }
function DBGW() { try { if (window.DEBUG_CONVERTER) console.warn.apply(console, arguments); } catch (e) { } }
function DBGE() { try { if (window.DEBUG_CONVERTER) console.error.apply(console, arguments); } catch (e) { } }
/* 1) Find/attach the FFmpeg wrapper no matter how it exports */
// --- FFmpeg wrapper bootstrap (drop-in) ---
// Guard against double-injection during dev
window.FFMPEG_VER = window.FFMPEG_VER || '0.12.10';
var FFMPEG_VER = window.FFMPEG_VER;  // <— was 'const', change to 'var'

var _warmFFmpegOnce = window._warmFFmpegOnce || null;  // ⬅️ change this line
if (window.__APP_ALREADY_LOADED__) throw new Error('app.js loaded twice');
window.__APP_ALREADY_LOADED__ = true;
const TB_TONE = {
  'banner.doneOk': 'ok',
  'banner.finishedMixed': 'error',
  'banner.finishedFail': 'error',
  'banner.noCommonFor': 'error',
  'banner.unsupportedPresent': 'error',
  'banner.unsupportedAdded': 'error',
  'banner.added': 'ok',
  'banner.removedX': 'ok',
  'banner.cleared': 'ok',
  'banner.addFirst': 'error',
  'banner.noOutputs': 'error',
  'banner.exceedsBudget': 'error'
};
window.tb = function tb(key, vars) {
  const tone = TB_TONE[key] || 'error';           // default to red if unknown
  return showBanner(t(key, vars), tone);
};
// adopt any known global shape
function adoptFFmpegGlobal() {
  const cands = [
    () => globalThis.FFmpeg,
    () => window.FFmpeg,
    () => window.FFmpegWASM?.FFmpeg,
    () => window.FFmpegWASM,
    () => window.FFmpegWasm,
    () => window.ffmpeg, // some forks
  ];
  for (const get of cands) {
    const g = get();
    if (g && typeof g.createFFmpeg === 'function') {
      window.FFmpeg = g;
      return true;
    }
  }
  return false;
}
import { loadJSZip, loadLibarchive, load7z } from '/src/local-first.mjs';

// ZIP writer
const JSZip = await loadJSZip();

// libarchive-wasm reader (RAR/7Z/TAR/ZIP inputs)
const { ArchiveReader, libarchiveWasm } = await loadLibarchive();
const mod = await libarchiveWasm();
// Example: const reader = new ArchiveReader(mod, new Int8Array(await file.arrayBuffer()));

// 7z writer (for .7z or ZIP AES via 7z)
const seven = await load7z(); // seven.FS, seven.callMain([...])

// Local-only: adopt/create a FFmpeg global from the local UMD wrapper.
// No CDN, no ESM import — prevents cross-origin Worker.
async function ensureFFmpegGlobal() {
  // already present?
  if (window.FFmpeg?.createFFmpeg) return true;

  // load the local classic UMD wrapper
  try {
    await (function loadClassicScript(src) {
      return new Promise((res, rej) => {
        const s = document.createElement('script');
        s.src = src; s.async = true;
        s.onload = res; s.onerror = () => rej(new Error('Failed to load ' + src));
        document.head.appendChild(s);
      });
    })('/vendor/ffmpeg/ffmpeg.min.js');
  } catch (e) {
    console.error('Local ffmpeg.js failed to load:', e);
    return false;
  }

  // normalize alt namespace (some builds export as FFmpegWASM)
  if (!window.FFmpeg?.createFFmpeg && window.FFmpegWASM?.FFmpeg) {
    const FFmpegClass = window.FFmpegWASM.FFmpeg;
    const fetchFile = window.FFmpegWASM.fetchFile;
    window.FFmpeg = { createFFmpeg: (opts = {}) => new FFmpegClass(opts), fetchFile };
  }

  return !!(window.FFmpeg && window.FFmpeg.createFFmpeg);
}


function show(msg, kind = 'info') {
  if (typeof showBanner === 'function') return showBanner(msg, kind);
  console[kind === 'error' ? 'error' : 'log'](msg);
}

async function headOrGet(url) {
  try {
    let r = await fetch(url, { method: 'HEAD', cache: 'no-store' });
    if (!r.ok && r.status === 405) r = await fetch(url, { method: 'GET', cache: 'no-store' });
    return { url, ok: r.ok, status: r.status, ct: r.headers.get('content-type') || '' };
  } catch (e) {
    return { url, ok: false, status: 0, error: String(e?.message || e) };
  }
}

function loadClassicScript(src) {
  return new Promise((res, rej) => {
    const s = document.createElement('script');
    s.src = src;
    s.async = true;            // classic script (NOT type="module")
    s.onload = res;
    s.onerror = rej;
    document.head.appendChild(s);
  });
}

async function diagnoseWrapper(src, reason) {
  const h = await headOrGet(src);
  console.log('[FFmpeg wrapper check]', h);
  if (!h.ok) {
    show(`FFmpeg wrapper not reachable at ${src}`, 'error');
  } else if (!/javascript|ecmascript/i.test(h.ct)) {
    show(`FFmpeg wrapper served as ${h.ct} (likely an HTML fallback).`, 'error');
  } else {
    show(reason || 'ffmpeg.js loaded but did not expose createFFmpeg (wrong build/namespace).', 'error');
  }
}
// === END DEBUG INSTRUMENTATION v3 ===
// Show an actionable error in the banner and clean up the row UI.
function friendlyCatch(err, { status, card, runId }) {
  try {
    if (typeof isStale === 'function' && isStale(runId)) return; // a newer run started

    if (status) {
      status.textContent = t('failed');
      status.style.color = 'var(--danger)';
    }
    card?.classList?.remove('is-converting');

    // Try to present a specific reason
    const msg =
      (err && (err.message || err.details)) ||
      (typeof err === 'string' ? err : '') ||
      t('unknownError');

    // If it smells like a PDF.js version mismatch, add a hint
    const hint = /version|Worker|API/i.test(msg)
      ? ' (Check that your PDF.js main library and worker are the same major version.)'
      : '';

    if (typeof showBanner === 'function') {
      showBanner(`Couldn’t convert: ${msg}${hint}`, 'error');
    } else {
      console.error('[ui suppressed]', `Couldn’t convert: ${msg}${hint}`);
    }
  } catch (uiErr) {
    // Never let the error handler throw
    console.error('Error while showing error:', uiErr, 'Original:', err);
  }
}

/* app.js — full, fixed, copy-paste ready (waits for vendor libs) */

/* ========= 1) Config toggles ========= */
// Config toggles (add media: true)
const ENABLE_OUTPUTS = {
  images: true,        // PNG, JPEG, WebP, SVG
  documents: true,     // PDF, DOCX
  text: true,          // TXT, MD, HTML, CSV, JSON, JSONL, RTF
  spreadsheets: true,  // XLSX
  media: true          // ✅ MP3, WAV, OGG, M4A, MP4, WebM, GIF
};
let _ffmpegInstance = null;
async function needMammoth() {
  if (window.mammoth) return;
  try { await loadScript('/vendor/mammoth.browser.min.js'); }
  catch { await loadScript('https://unpkg.com/mammoth/mammoth.browser.min.js'); }
}

// Robust PDF.js loader: UMD or ESM, local first then CDN. No script tag for the worker.
// Robust PDF.js loader that keeps the main lib and the worker on the *same major version*.
async function needPdf() {
  // Already loaded?
  if (window.pdfjsLib?.getDocument) { features.pdf = true; ensureVendors?.(); return; }

  // Small helper
  const loadScript = (src) => new Promise((res, rej) => {
    const s = document.createElement('script');
    s.src = src; s.async = true;
    s.onload = res; s.onerror = () => rej(new Error('Failed to load ' + src));
    document.head.appendChild(s);
  });

  // Try to load the *main* library (UMD first; if you only ship ESM, swap order)
  const mainCandidates = [
    // local UMD → CDN UMD → local ESM → CDN ESM
    () => loadScript('/vendor/pdf.min.js'),
    () => loadScript('https://unpkg.com/pdfjs-dist@4/legacy/build/pdf.min.js'),
    async () => { window.pdfjsLib = await import('/vendor/pdf.min.mjs'); },
    async () => { window.pdfjsLib = await import('https://unpkg.com/pdfjs-dist@4/build/pdf.mjs'); },
  ];

  let mainLoaded = false, lastErr = null;
  for (const attempt of mainCandidates) {
    try { await attempt(); mainLoaded = true; break; }
    catch (e) { lastErr = e; }
  }
  if (!mainLoaded || !window.pdfjsLib?.getDocument) {
    throw lastErr || new Error('Unable to load pdfjs main library');
  }

  // Decide worker version based on the *main library* we just loaded.
  const version = String(window.pdfjsLib?.version || '');
  const isV4 = version.startsWith('4.');
  const workerCandidates = isV4
    ? [
      // Prefer your local v4 worker if you ship it; otherwise the CDN v4 worker
      '/vendor/pdf.worker.min.js', // make sure this is v4 if present
      'https://unpkg.com/pdfjs-dist@4/legacy/build/pdf.worker.min.js',
      'https://unpkg.com/pdfjs-dist@4/build/pdf.worker.min.mjs',
    ]
    : [
      // v3 track (use if you intentionally pin to 3.x)
      '/vendor/pdf.worker.min.js',
      'https://unpkg.com/pdfjs-dist@3/legacy/build/pdf.worker.min.js',
      'https://unpkg.com/pdfjs-dist@3/build/pdf.worker.min.mjs',
    ];

  // Pick the first reachable worker (HEAD request when possible; file:// may throw)
  let workerSrc = workerCandidates[0];
  for (const url of workerCandidates) {
    try {
      const ok = await fetch(url, { method: 'HEAD', cache: 'no-store' }).then(r => r.ok);
      if (ok) { workerSrc = url; break; }
    } catch { /* offline or file:// → keep default */ }
  }

  // Bind worker to the main lib (only if that API exists on this build)
  if (window.pdfjsLib?.GlobalWorkerOptions) {
    window.pdfjsLib.GlobalWorkerOptions.workerSrc = workerSrc;
  }

  features.pdf = true;
  ensureVendors?.();   // (optional) refresh any UI badges you show
}






async function needXLSX() {
  if (window.XLSX) { features.xlsx = true; ensureVendors?.(); return; }
  await loadScriptTry(CDN.xlsx[0], CDN.xlsx[1]);
  features.xlsx = !!window.XLSX;
  ensureVendors?.();
}

async function needJSZip() {
  if (window.JSZip) { features.pptx = true; ensureVendors?.(); return; }
  await loadScriptTry(CDN.jszip[0], CDN.jszip[1]);
  features.pptx = !!window.JSZip;
  ensureVendors?.();
}

async function needJsPDF() {
  if (window.jspdf?.jsPDF) { features.makePdf = true; ensureVendors?.(); return; }
  await loadScriptTry(CDN.jspdf[0], CDN.jspdf[1]);
  features.makePdf = !!(window.jspdf && window.jspdf.jsPDF);
  ensureVendors?.();
}

async function needDocx() {
  if (window.docx) { features.makeDocx = true; ensureVendors?.(); return; }
  await loadScriptTry(CDN.docx[0], CDN.docx[1]);
  features.makeDocx = !!window.docx;
  ensureVendors?.();
}

// Global helper: returns the localized singular/plural for "file"
// Global helper: localized singular/plural for "file"
window.wordFiles = function wordFiles(n, lang) {
  const one = {
    "en": "file", "de": "Datei", "es": "archivo", "fr": "fichier", "it": "file",
    "pl": "plik", "pt": "ficheiro", "pt-br": "arquivo", "ja": "ファイル", "ru": "файл",
    "zh-cn": "个文件", "ko": "파일", "hi": "फ़ाइल", "ar": "ملف", "uk": "файл",
    "tr": "dosya", "nl": "bestand"
  };
  const many = {
    "en": "files", "de": "Dateien", "es": "archivos", "fr": "fichiers", "it": "file",
    "pl": "pliki", "pt": "ficheiros", "pt-br": "arquivos", "ja": "ファイル", "ru": "файлы",
    "zh-cn": "个文件", "ko": "파일", "hi": "फ़ाइलें", "ar": "ملفات", "uk": "файли",
    "tr": "dosya", "nl": "bestanden"
  };
  const Lraw = String(lang || (window.APP_LANG || "en")).toLowerCase();
  const L = one[Lraw] ? Lraw : (Lraw.split("-")[0] || "en");
  const s = Number(n) || 0;
  return s === 1 ? (one[L] || one.en) : (many[L] || many.en);
};

// Interceptor: translates banners + normalizes the "Done ..." message
// Interceptor: translate + normalize the "Done ..." message
// Interceptor: translate + normalize the "Done ..." message
window.showBanner = function (msg, kind = 'info') {
  try {
    let m = String(msg);

    // Simple English -> i18n
    if (m === 'Cleared.') m = t('banner.cleared');
    else if (m === 'No outputs yet. Convert first.') m = t('banner.noOutputs');
    else if (m === 'Add some files first.') m = t('banner.addFirst');

    // Handle: "Done. X succeeded, Y failed." or ICU leak
    const doneMatch = m.match(/\bDone\.\s+(\d+)\s+succeeded\b/i);
    if (doneMatch) {
      const s = parseInt(doneMatch[1], 10) || 0;
      const failMatch = m.match(/,\s*(\d+)\s+failed/i);
      const f = failMatch ? (parseInt(failMatch[1], 10) || 0) : 0;

      const L = window.APP_LANG || 'en';
      if (f === 0) {
        tb('banner.doneOk', { s, files: wordFiles(s, L) });       // ✅ green
      } else if (s > 0) {
        tb('banner.finishedMixed', { s, files: wordFiles(s, L), f });    // ❌ red
      } else {
        tb('banner.finishedFail', { f, files: wordFiles(f, L) });       // ❌ red
      }

      const filesS = window.wordFiles(s, L);
      const filesF = window.wordFiles(f, L);

      const hasI18n =
        (typeof I18N !== 'undefined') &&
        ((I18N[L] && (I18N[L]['banner.doneOk'] || I18N[L]['banner.doneMixed'] || I18N[L]['banner.doneFail'])) ||
          (I18N.en && (I18N.en['banner.doneOk'] || I18N.en['banner.doneMixed'] || I18N.en['banner.doneFail'])));

      if (hasI18n) {
        if (f > 0 && s === 0) m = t('banner.doneFail', { f, files: filesF });
        else if (f > 0) m = t('banner.doneMixed', { s, files: filesS, f });
        else m = t('banner.doneOk', { s, files: filesS });
      } else {
        // Fallback English sentence, but with localized "file/files"
        if (f > 0 && s === 0) m = `Failed ${f} ${filesF}.`;
        else if (f > 0) m = `Done. ${s} ${filesS} converted, ${f} failed.`;
        else m = `Done. ${s} ${filesS} converted.`;

      }
    }
    else if (/^Too much data at once \((.+)\)\. Budget (.+)\.$/.test(m)) {
      const mm = m.match(/^Too much data at once \((.+)\)\. Budget (.+)\.$/);
      if (mm) m = t('banner.tooMuchData', { total: mm[1], budget: mm[2] });
    } else if (/^Total selected (.+) exceeds budget (.+)\. Will process sequentially\.$/.test(m)) {
      const mm = m.match(/^Total selected (.+) exceeds budget (.+)\. Will process sequentially\.$/);
      if (mm) m = t('banner.exceedsBudget', { total: mm[1], budget: mm[2] });
    } else if (m === 'Triggered downloads for each file.') m = t('banner.triggeredDownloads');
    else if (m === 'Saved all files to your chosen folder.') m = t('banner.savedAll');
    else if (m === 'Save cancelled.') m = t('banner.saveCancelled');
    else if (m === 'Link copied to clipboard.') m = t('banner.linkCopied');
    else if (/^Couldn’t open the folder\./.test(m)) m = t('banner.openFolderFail');

    console[kind === 'error' ? 'error' : 'log'](m);
  } catch {
    console[kind === 'error' ? 'error' : 'log'](msg);
  }
};


// Populate the dropdown from these (popular output types)
const TARGET_GROUPS = {
  text: [
    ['txt', 'Plain text (.txt)'],
    ['md', 'Markdown (.md)'],
    ['html', 'HTML (.html)'],
    ['csv', 'CSV (.csv)'],
    ['json', 'JSON (.json)'],
    ['jsonl', 'JSON Lines (.jsonl)'],
    ['rtf', 'Rich Text (.rtf)']
  ],
  documents: [
    ['pdf', 'PDF (.pdf)'],
    ['docx', 'Word DOCX (.docx)']

  ],
  spreadsheets: [
    ['xlsx', 'Excel XLSX (.xlsx)']
  ],
  images: [
    ['png', 'PNG (.png)'],
    ['jpeg', 'JPEG (.jpg)'],
    ['webp', 'WebP (.webp)'],
    ['svg', 'SVG (.svg)']
  ],
  media: [
    ['mp3', 'Audio MP3 (.mp3)'],
    ['wav', 'Audio WAV (.wav)'],
    ['ogg', 'Audio OGG (.ogg)'],
    ['m4a', 'Audio M4A (.m4a)'],
    ['mp4', 'Video MP4 (.mp4)'],
    ['webm', 'Video WebM (.webm)'],
    ['gif', 'GIF from video (.gif)'],
  ],
  archives: [
    ['zip', 'ZIP (.zip)'],
    ['7z', '7Z (.7z)'],
    ['tar', 'TAR (.tar)'],
    ['tar.gz', 'TAR.GZ (.tar.gz)'],
    ['tar.bz2', 'TAR.BZ2 (.tar.bz2)'],
    ['tar.xz', 'TAR.XZ (.tar.xz)']
  ]
};

// Optional: show the demo ad panels
const SHOW_ADS = true;

/* ========= 2) Small helpers ========= */
const $ = (s, r = document) => r.querySelector(s);
const el = (t, c) => { const e = document.createElement(t); if (c) e.className = c; return e; };
const fmtBytes = b => { const u = ['B', 'KB', 'MB', 'GB']; let i = 0, n = b; while (n >= 1024 && i < u.length - 1) { n /= 1024; i++; } return `${n.toFixed(n < 10 && i > 0 ? 1 : 0)} ${u[i]}`; };
const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
const escapeHtml = (s) =>
  String(s ?? '').replace(/[&<>"']/g, m => (
    { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": "&#39;" }[m]
  ));

const swapExt = (name, ext) => (name.lastIndexOf('.') > 0 ? name.slice(0, name.lastIndexOf('.')) : name) + '.' + ext;
const baseName = n => (n.lastIndexOf('.') > 0 ? n.slice(0, n.lastIndexOf('.')) : n);

function estimateSafeBudgetBytes() {
  try { if (performance?.memory?.jsHeapSizeLimit) { const lim = performance.memory.jsHeapSizeLimit; return Math.max(80 * 1024 * 1024, Math.min(lim * 0.15, 500 * 1024 * 1024)); } } catch (e) { }
  const dm = navigator.deviceMemory || 4; const est = dm * 0.05 * 1024 * 1024 * 1024; return Math.max(80 * 1024 * 1024, Math.min(est, 400 * 1024 * 1024));
}

/* ========= 3) Vendor loader with local+CDN fallback ========= */
const features = { pdf: false, docx: false, xlsx: false, pptx: false, ocr: false, makePdf: false, makeDocx: false, ffmpeg: false };

/* ========= i18n: light-weight runtime translations ========= */
const I18N = {
  en: {
    // statuses / controls
    queued: 'queued',
    preparing: 'Preparing…',
    converting: 'Converting…',
    convertingPct: 'Converting… {pct}%',
    finishing: 'Finishing…',
    ready: 'Ready',
    readyN: 'Ready ({n} files)',
    failed: 'Failed',
    remove: 'Remove',
    unknown: 'unknown',
    downloadX: 'Download {name}',
    group_archives: 'Archives',
    // groups
    group_text: 'Text',
    group_documents: 'Documents',
    group_spreadsheets: 'Spreadsheets',
    group_images: 'Images',
    group_media: 'Media',

    // options (simple)
    'opt.txt': 'Plain text (.txt)',
    'opt.md': 'Markdown (.md)',
    'opt.html': 'HTML (.html)',
    'opt.csv': 'CSV (.csv)',
    'opt.json': 'JSON (.json)',
    'opt.jsonl': 'JSON Lines (.jsonl)',
    'opt.rtf': 'Rich Text (.rtf)',
    'opt.pdf': 'PDF (.pdf)',
    'opt.docx': 'Word DOCX (.docx)',
    'opt.xlsx': 'Excel XLSX (.xlsx)',
    'opt.png': 'PNG (.png)',
    'opt.jpeg': 'JPEG (.jpg)',
    'opt.webp': 'WebP (.webp)',
    'opt.svg': 'SVG (.svg)',
    'opt.gif': 'GIF from video (.gif)',
    'opt.audioGeneric': 'Audio {fmt} ({ext})',
    'opt.videoGeneric': 'Video {fmt} ({ext})',

    // banners
    'banner.cleared': 'Cleared.',
    'banner.noOutputs': 'No outputs yet. Convert first.',
    'banner.addFirst': 'Add some files first.',
    'banner.doneSummary': 'Done {s} {files}!',
    'banner.tooMuchData': 'Too much data at once ({total}). Budget {budget}.',
    'banner.exceedsBudget': 'Total selected {total} exceeds budget {budget}. Will process sequentially.',
    'banner.triggeredDownloads': 'Triggered downloads for each file.',
    'banner.savedAll': 'Saved all files to your chosen folder.',
    'banner.saveCancelled': 'Save cancelled.',
    'banner.linkCopied': 'Link copied to clipboard.',
    'banner.openFolderFail': 'Couldn’t open the folder. Try again or download individually below.',

    // errors
    couldntConvert: 'Couldn’t convert: {msg}',
    unknownError: 'Unknown error'
  },

  // --- Localized keys ---
  de: {
    queued: 'In der Warteschlange',
    preparing: 'Wird vorbereitet…',
    converting: 'Wird konvertiert…',
    convertingPct: 'Wird konvertiert… {pct}%',
    finishing: 'Wird abgeschlossen…',
    ready: 'Fertig',
    readyN: 'Fertig ({n} Dateien)',
    failed: 'Fehlgeschlagen',
    remove: 'Entfernen',
    unknown: 'unbekannt',
    downloadX: '{name} herunterladen',
    group_text: 'Text',
    group_documents: 'Dokumente',
    group_spreadsheets: 'Tabellen',
    group_images: 'Bilder',
    group_media: 'Medien',
    'opt.txt': 'Einfacher Text (.txt)',
    'opt.md': 'Markdown (.md)',
    'opt.html': 'HTML (.html)',
    'opt.csv': 'CSV (.csv)',
    'opt.json': 'JSON (.json)',
    'opt.jsonl': 'JSON Lines (.jsonl)',
    'opt.rtf': 'Rich Text (.rtf)',
    'opt.pdf': 'PDF (.pdf)',
    'opt.docx': 'Word DOCX (.docx)',
    'opt.xlsx': 'Excel XLSX (.xlsx)',
    'opt.png': 'PNG (.png)',
    'opt.jpeg': 'JPEG (.jpg)',
    'opt.webp': 'WebP (.webp)',
    'opt.svg': 'SVG (.svg)',
    'opt.gif': 'GIF aus Video (.gif)',
    'opt.audioGeneric': 'Audio {fmt} ({ext})',
    'opt.videoGeneric': 'Video {fmt} ({ext})',
    'banner.cleared': 'Geleert.',
    'banner.noOutputs': 'Noch keine Ergebnisse. Bitte zuerst konvertieren.',
    'banner.addFirst': 'Fügen Sie zuerst Dateien hinzu.',
    'banner.doneSummary': 'Fertig: {s} {files}!',
    'banner.tooMuchData': 'Zu viele Daten auf einmal ({total}). Budget {budget}.',
    'banner.exceedsBudget': 'Gesamtauswahl {total} überschreitet das Budget {budget}. Verarbeitung nacheinander.',
    'banner.triggeredDownloads': 'Downloads für jede Datei gestartet.',
    'banner.savedAll': 'Alle Dateien in den gewählten Ordner gespeichert.',
    'banner.saveCancelled': 'Speichern abgebrochen.',
    'banner.linkCopied': 'Link in die Zwischenablage kopiert.',
    'banner.openFolderFail': 'Ordner konnte nicht geöffnet werden. Versuchen Sie es erneut oder laden Sie einzeln herunter.',
    couldntConvert: 'Konnte nicht konvertieren: {msg}',
    unknownError: 'Unbekannter Fehler'
  },

  es: {
    queued: 'En cola',
    preparing: 'Preparando…',
    converting: 'Convirtiendo…',
    convertingPct: 'Convirtiendo… {pct}%',
    finishing: 'Finalizando…',
    ready: 'Listo',
    readyN: 'Listo ({n} archivos)',
    failed: 'Fallido',
    remove: 'Quitar',
    unknown: 'desconocido',
    downloadX: 'Descargar {name}',
    group_text: 'Texto',
    group_documents: 'Documentos',
    group_spreadsheets: 'Hojas de cálculo',
    group_images: 'Imágenes',
    group_media: 'Medios',
    'opt.txt': 'Texto sin formato (.txt)',
    'opt.md': 'Markdown (.md)',
    'opt.html': 'HTML (.html)',
    'opt.csv': 'CSV (.csv)',
    'opt.json': 'JSON (.json)',
    'opt.jsonl': 'JSON Lines (.jsonl)',
    'opt.rtf': 'Rich Text (.rtf)',
    'opt.pdf': 'PDF (.pdf)',
    'opt.docx': 'Word DOCX (.docx)',
    'opt.xlsx': 'Excel XLSX (.xlsx)',
    'opt.png': 'PNG (.png)',
    'opt.jpeg': 'JPEG (.jpg)',
    'opt.webp': 'WebP (.webp)',
    'opt.svg': 'SVG (.svg)',
    'opt.gif': 'GIF desde un vídeo (.gif)',
    'opt.audioGeneric': 'Audio {fmt} ({ext})',
    'opt.videoGeneric': 'Vídeo {fmt} ({ext})',
    'banner.cleared': 'Borrado.',
    'banner.noOutputs': 'Aún no hay resultados. Convierta primero.',
    'banner.addFirst': 'Añada archivos primero.',
    'banner.doneSummary': 'Listo: {s} {files}!',
    'banner.tooMuchData': 'Demasiados datos a la vez ({total}). Límite {budget}.',
    'banner.exceedsBudget': 'El total seleccionado {total} supera el límite {budget}. Se procesará secuencialmente.',
    'banner.triggeredDownloads': 'Descargas iniciadas para cada archivo.',
    'banner.savedAll': 'Todos los archivos guardados en la carpeta elegida.',
    'banner.saveCancelled': 'Guardado cancelado.',
    'banner.linkCopied': 'Enlace copiado al portapapeles.',
    'banner.openFolderFail': 'No se pudo abrir la carpeta. Inténtelo de nuevo o descargue individualmente.',
    couldntConvert: 'No se pudo convertir: {msg}',
    unknownError: 'Error desconocido'
  },

  fr: {
    queued: 'En file d’attente',
    preparing: 'Préparation…',
    converting: 'Conversion en cours…',
    convertingPct: 'Conversion… {pct} %',
    finishing: 'Finalisation…',
    ready: 'Prêt',
    readyN: 'Prêt ({n} fichiers)',
    failed: 'Échec',
    remove: 'Supprimer',
    unknown: 'inconnu',
    downloadX: 'Télécharger {name}',
    group_text: 'Texte',
    group_documents: 'Documents',
    group_spreadsheets: 'Feuilles de calcul',
    group_images: 'Images',
    group_media: 'Médias',
    'opt.txt': 'Texte brut (.txt)',
    'opt.md': 'Markdown (.md)',
    'opt.html': 'HTML (.html)',
    'opt.csv': 'CSV (.csv)',
    'opt.json': 'JSON (.json)',
    'opt.jsonl': 'JSON Lines (.jsonl)',
    'opt.rtf': 'Texte enrichi (.rtf)',
    'opt.pdf': 'PDF (.pdf)',
    'opt.docx': 'Word DOCX (.docx)',
    'opt.xlsx': 'Excel XLSX (.xlsx)',
    'opt.png': 'PNG (.png)',
    'opt.jpeg': 'JPEG (.jpg)',
    'opt.webp': 'WebP (.webp)',
    'opt.svg': 'SVG (.svg)',
    'opt.gif': 'GIF depuis une vidéo (.gif)',
    'opt.audioGeneric': 'Audio {fmt} ({ext})',
    'opt.videoGeneric': 'Vidéo {fmt} ({ext})',
    'banner.cleared': 'Réinitialisé.',
    'banner.noOutputs': 'Aucun résultat pour l’instant. Lancez une conversion.',
    'banner.addFirst': 'Ajoutez des fichiers d’abord.',
    'banner.doneSummary': 'Terminé : {s} {files} !',
    'banner.tooMuchData': 'Trop de données à la fois ({total}). Budget {budget}.',
    'banner.exceedsBudget': 'Le total sélectionné {total} dépasse le budget {budget}. Traitement séquentiel.',
    'banner.triggeredDownloads': 'Téléchargements lancés pour chaque fichier.',
    'banner.savedAll': 'Tous les fichiers enregistrés dans le dossier choisi.',
    'banner.saveCancelled': 'Enregistrement annulé.',
    'banner.linkCopied': 'Lien copié dans le presse-papiers.',
    'banner.openFolderFail': 'Impossible d’ouvrir le dossier. Réessayez ou téléchargez individuellement.',
    couldntConvert: 'Conversion impossible : {msg}',
    unknownError: 'Erreur inconnue'
  },

  it: {
    queued: 'In coda',
    preparing: 'Preparazione…',
    converting: 'Conversione in corso…',
    convertingPct: 'Conversione in corso… {pct}%',
    finishing: 'Finalizzazione…',
    ready: 'Pronto',
    readyN: 'Pronto ({n} file)',
    failed: 'Non riuscito',
    remove: 'Rimuovi',
    unknown: 'sconosciuto',
    downloadX: 'Scarica {name}',
    group_text: 'Testo',
    group_documents: 'Documenti',
    group_spreadsheets: 'Fogli di calcolo',
    group_images: 'Immagini',
    group_media: 'Media',
    'opt.txt': 'Testo semplice (.txt)',
    'opt.md': 'Markdown (.md)',
    'opt.html': 'HTML (.html)',
    'opt.csv': 'CSV (.csv)',
    'opt.json': 'JSON (.json)',
    'opt.jsonl': 'Righe JSON (.jsonl)',
    'opt.rtf': 'Testo RTF (.rtf)',
    'opt.pdf': 'PDF (.pdf)',
    'opt.docx': 'Word DOCX (.docx)',
    'opt.xlsx': 'Excel XLSX (.xlsx)',
    'opt.png': 'PNG (.png)',
    'opt.jpeg': 'JPEG (.jpg)',
    'opt.webp': 'WebP (.webp)',
    'opt.svg': 'SVG (.svg)',
    'opt.gif': 'GIF da video (.gif)',
    'opt.audioGeneric': 'Audio {fmt} ({ext})',
    'opt.videoGeneric': 'Video {fmt} ({ext})',
    'banner.cleared': 'Svuotato.',
    'banner.noOutputs': 'Nessun output al momento. Esegui prima la conversione.',
    'banner.addFirst': 'Aggiungi prima alcuni file.',
    'banner.doneSummary': 'Fatto: {s} {files}!',
    'banner.tooMuchData': 'Troppi dati in una volta ({total}). Budget {budget}.',
    'banner.exceedsBudget': 'Il totale selezionato {total} supera il budget {budget}. Verrà elaborato in modo sequenziale.',
    'banner.triggeredDownloads': 'Avviati i download per ogni file.',
    'banner.savedAll': 'Tutti i file salvati nella cartella scelta.',
    'banner.saveCancelled': 'Salvataggio annullato.',
    'banner.linkCopied': 'Link copiato negli appunti.',
    'banner.openFolderFail': 'Impossibile aprire la cartella. Riprova o scarica i file singolarmente qui sotto.',
    couldntConvert: 'Impossibile convertire: {msg}',
    unknownError: 'Errore sconosciuto'
  },

  pl: {
    queued: 'W kolejce',
    preparing: 'Przygotowywanie…',
    converting: 'Konwertowanie…',
    convertingPct: 'Konwertowanie… {pct}%',
    finishing: 'Finalizowanie…',
    ready: 'Gotowe',
    readyN: 'Gotowe ({n} plików)',
    failed: 'Niepowodzenie',
    remove: 'Usuń',
    unknown: 'nieznane',
    downloadX: 'Pobierz {name}',
    group_text: 'Tekst',
    group_documents: 'Dokumenty',
    group_spreadsheets: 'Arkusze kalkulacyjne',
    group_images: 'Obrazy',
    group_media: 'Multimedia',
    'opt.txt': 'Zwykły tekst (.txt)',
    'opt.md': 'Markdown (.md)',
    'opt.html': 'HTML (.html)',
    'opt.csv': 'CSV (.csv)',
    'opt.json': 'JSON (.json)',
    'opt.jsonl': 'Wiersze JSON (.jsonl)',
    'opt.rtf': 'Tekst RTF (.rtf)',
    'opt.pdf': 'PDF (.pdf)',
    'opt.docx': 'Word DOCX (.docx)',
    'opt.xlsx': 'Excel XLSX (.xlsx)',
    'opt.png': 'PNG (.png)',
    'opt.jpeg': 'JPEG (.jpg)',
    'opt.webp': 'WebP (.webp)',
    'opt.svg': 'SVG (.svg)',
    'opt.gif': 'GIF z wideo (.gif)',
    'opt.audioGeneric': 'Audio {fmt} ({ext})',
    'opt.videoGeneric': 'Wideo {fmt} ({ext})',
    'banner.cleared': 'Wyczyszczono.',
    'banner.noOutputs': 'Brak wyników. Najpierw wykonaj konwersję.',
    'banner.addFirst': 'Najpierw dodaj pliki.',
    'banner.doneSummary': 'Ukończono: {s} {files}!',
    'banner.tooMuchData': 'Zbyt dużo danych naraz ({total}). Budżet {budget}.',
    'banner.exceedsBudget': 'Suma {total} przekracza budżet {budget}. Przetwarzanie sekwencyjne.',
    'banner.triggeredDownloads': 'Uruchomiono pobieranie dla każdego pliku.',
    'banner.savedAll': 'Zapisano wszystkie pliki do wybranego folderu.',
    'banner.saveCancelled': 'Zapisywanie anulowano.',
    'banner.linkCopied': 'Link skopiowano do schowka.',
    'banner.openFolderFail': 'Nie można było otworzyć folderu. Spróbuj ponownie lub pobierz pojedynczo poniżej.',
    couldntConvert: 'Nie można przekonwertować: {msg}',
    unknownError: 'Nieznany błąd'
  },

  pt: {
    queued: 'Na fila',
    preparing: 'Preparando…',
    converting: 'Convertendo…',
    convertingPct: 'Convertendo… {pct}%',
    finishing: 'Finalizando…',
    ready: 'Pronto',
    readyN: 'Pronto ({n} ficheiros)',
    failed: 'Falha',
    remove: 'Remover',
    unknown: 'desconhecido',
    downloadX: 'Transferir {name}',
    group_text: 'Texto',
    group_documents: 'Documentos',
    group_spreadsheets: 'Folhas de cálculo',
    group_images: 'Imagens',
    group_media: 'Multimédia',
    'opt.txt': 'Texto simples (.txt)',
    'opt.md': 'Markdown (.md)',
    'opt.html': 'HTML (.html)',
    'opt.csv': 'CSV (.csv)',
    'opt.json': 'JSON (.json)',
    'opt.jsonl': 'Linhas JSON (.jsonl)',
    'opt.rtf': 'Texto RTF (.rtf)',
    'opt.pdf': 'PDF (.pdf)',
    'opt.docx': 'Word DOCX (.docx)',
    'opt.xlsx': 'Excel XLSX (.xlsx)',
    'opt.png': 'PNG (.png)',
    'opt.jpeg': 'JPEG (.jpg)',
    'opt.webp': 'WebP (.webp)',
    'opt.svg': 'SVG (.svg)',
    'opt.gif': 'GIF de vídeo (.gif)',
    'opt.audioGeneric': 'Áudio {fmt} ({ext})',
    'opt.videoGeneric': 'Vídeo {fmt} ({ext})',
    'banner.cleared': 'Limpo.',
    'banner.noOutputs': 'Ainda não há resultados. Converta primeiro.',
    'banner.addFirst': 'Adicione ficheiros primeiro.',
    'banner.doneSummary': 'Concluído: {s} {files}!',
    'banner.tooMuchData': 'Demasiados dados de uma vez ({total}). Orçamento {budget}.',
    'banner.exceedsBudget': 'Total selecionado {total} excede o orçamento {budget}. Será processado sequencialmente.',
    'banner.triggeredDownloads': 'Transferências iniciadas para cada ficheiro.',
    'banner.savedAll': 'Todos os ficheiros guardados na pasta escolhida.',
    'banner.saveCancelled': 'Guardar cancelado.',
    'banner.linkCopied': 'Ligação copiada para a área de transferência.',
    'banner.openFolderFail': 'Não foi possível abrir a pasta. Tente novamente ou transfira individualmente abaixo.',
    couldntConvert: 'Não foi possível converter: {msg}',
    unknownError: 'Erro desconhecido'
  },

  'pt-BR': {
    queued: 'Na fila',
    preparing: 'Preparando…',
    converting: 'Convertendo…',
    convertingPct: 'Convertendo… {pct}%',
    finishing: 'Finalizando…',
    ready: 'Pronto',
    readyN: 'Pronto ({n} arquivos)',
    failed: 'Falha',
    remove: 'Remover',
    unknown: 'desconhecido',
    downloadX: 'Baixar {name}',
    group_text: 'Texto',
    group_documents: 'Documentos',
    group_spreadsheets: 'Planilhas',
    group_images: 'Imagens',
    group_media: 'Mídia',
    'opt.txt': 'Texto simples (.txt)',
    'opt.md': 'Markdown (.md)',
    'opt.html': 'HTML (.html)',
    'opt.csv': 'CSV (.csv)',
    'opt.json': 'JSON (.json)',
    'opt.jsonl': 'Linhas JSON (.jsonl)',
    'opt.rtf': 'Texto RTF (.rtf)',
    'opt.pdf': 'PDF (.pdf)',
    'opt.docx': 'Word DOCX (.docx)',
    'opt.xlsx': 'Excel XLSX (.xlsx)',
    'opt.png': 'PNG (.png)',
    'opt.jpeg': 'JPEG (.jpg)',
    'opt.webp': 'WebP (.webp)',
    'opt.svg': 'SVG (.svg)',
    'opt.gif': 'GIF de vídeo (.gif)',
    'opt.audioGeneric': 'Áudio {fmt} ({ext})',
    'opt.videoGeneric': 'Vídeo {fmt} ({ext})',
    'banner.cleared': 'Limpo.',
    'banner.noOutputs': 'Ainda não há resultados. Converta primeiro.',
    'banner.addFirst': 'Adicione arquivos primeiro.',
    'banner.doneSummary': 'Concluído: {s} {files}!',
    'banner.tooMuchData': 'Dados demais de uma vez ({total}). Orçamento {budget}.',
    'banner.exceedsBudget': 'Total selecionado {total} excede o orçamento {budget}. Será processado sequencialmente.',
    'banner.triggeredDownloads': 'Downloads iniciados para cada arquivo.',
    'banner.savedAll': 'Todos os arquivos salvos na pasta escolhida.',
    'banner.saveCancelled': 'Salvamento cancelado.',
    'banner.linkCopied': 'Link copiado para a área de transferência.',
    'banner.openFolderFail': 'Não foi possível abrir a pasta. Tente novamente ou baixe os arquivos individualmente abaixo.',
    couldntConvert: 'Não foi possível converter: {msg}',
    unknownError: 'Erro desconhecido'
  },

  ja: {
    queued: '待機中',
    preparing: '準備中…',
    converting: '変換中…',
    convertingPct: '変換中… {pct}%',
    finishing: '完了処理中…',
    ready: '完了',
    readyN: '完了（{n} ファイル）',
    failed: '失敗',
    remove: '削除',
    unknown: '不明',
    downloadX: '{name} をダウンロード',
    group_text: 'テキスト',
    group_documents: 'ドキュメント',
    group_spreadsheets: 'スプレッドシート',
    group_images: '画像',
    group_media: 'メディア',
    'opt.txt': 'プレーンテキスト (.txt)',
    'opt.md': 'Markdown (.md)',
    'opt.html': 'HTML (.html)',
    'opt.csv': 'CSV (.csv)',
    'opt.json': 'JSON (.json)',
    'opt.jsonl': 'JSON Lines (.jsonl)',
    'opt.rtf': 'リッチテキスト (.rtf)',
    'opt.pdf': 'PDF (.pdf)',
    'opt.docx': 'Word DOCX (.docx)',
    'opt.xlsx': 'Excel XLSX (.xlsx)',
    'opt.png': 'PNG (.png)',
    'opt.jpeg': 'JPEG (.jpg)',
    'opt.webp': 'WebP (.webp)',
    'opt.svg': 'SVG (.svg)',
    'opt.gif': '動画からGIF (.gif)',
    'opt.audioGeneric': '音声 {fmt} ({ext})',
    'opt.videoGeneric': '動画 {fmt} ({ext})',
    'banner.cleared': 'クリアしました。',
    'banner.noOutputs': '出力はまだありません。まず変換してください。',
    'banner.addFirst': '先にファイルを追加してください。',
    'banner.doneSummary': '{s} {files} を完了しました！',
    'banner.tooMuchData': '一度にデータが多すぎます（{total}）。上限 {budget}。',
    'banner.exceedsBudget': '選択合計 {total} が上限 {budget} を超えています。順次処理します。',
    'banner.triggeredDownloads': '各ファイルのダウンロードを開始しました。',
    'banner.savedAll': 'すべてのファイルを選択したフォルダに保存しました。',
    'banner.saveCancelled': '保存をキャンセルしました。',
    'banner.linkCopied': 'リンクをクリップボードにコピーしました。',
    'banner.openFolderFail': 'フォルダを開けませんでした。もう一度お試しになるか、下で個別にダウンロードしてください。',
    couldntConvert: '変換できませんでした: {msg}',
    unknownError: '不明なエラー'
  },

  ru: {
    queued: 'В очереди',
    preparing: 'Подготовка…',
    converting: 'Преобразование…',
    convertingPct: 'Преобразование… {pct}%',
    finishing: 'Завершение…',
    ready: 'Готово',
    readyN: 'Готово ({n} файлов)',
    failed: 'Сбой',
    remove: 'Удалить',
    unknown: 'неизвестно',
    downloadX: 'Скачать {name}',
    group_text: 'Текст',
    group_documents: 'Документы',
    group_spreadsheets: 'Таблицы',
    group_images: 'Изображения',
    group_media: 'Медиа',
    'opt.txt': 'Обычный текст (.txt)',
    'opt.md': 'Markdown (.md)',
    'opt.html': 'HTML (.html)',
    'opt.csv': 'CSV (.csv)',
    'opt.json': 'JSON (.json)',
    'opt.jsonl': 'JSON Lines (.jsonl)',
    'opt.rtf': 'Текст RTF (.rtf)',
    'opt.pdf': 'PDF (.pdf)',
    'opt.docx': 'Word DOCX (.docx)',
    'opt.xlsx': 'Excel XLSX (.xlsx)',
    'opt.png': 'PNG (.png)',
    'opt.jpeg': 'JPEG (.jpg)',
    'opt.webp': 'WebP (.webp)',
    'opt.svg': 'SVG (.svg)',
    'opt.gif': 'GIF из видео (.gif)',
    'opt.audioGeneric': 'Аудио {fmt} ({ext})',
    'opt.videoGeneric': 'Видео {fmt} ({ext})',
    'banner.cleared': 'Очищено.',
    'banner.noOutputs': 'Пока нет результатов. Сначала выполните преобразование.',
    'banner.addFirst': 'Сначала добавьте файлы.',
    'banner.doneSummary': 'Готово: {s} {files}!',
    'banner.tooMuchData': 'Слишком много данных за раз ({total}). Бюджет {budget}.',
    'banner.exceedsBudget': 'Общий выбранный объём {total} превышает бюджет {budget}. Обработка будет выполняться по очереди.',
    'banner.triggeredDownloads': 'Запущены загрузки для каждого файла.',
    'banner.savedAll': 'Все файлы сохранены в выбранную папку.',
    'banner.saveCancelled': 'Сохранение отменено.',
    'banner.linkCopied': 'Ссылка скопирована в буфер обмена.',
    'banner.openFolderFail': 'Не удалось открыть папку. Повторите попытку или загрузите файлы по одному ниже.',
    couldntConvert: 'Не удалось конвертировать: {msg}',
    unknownError: 'Неизвестная ошибка'
  },

  'zh-CN': {
    queued: '排队中',
    preparing: '准备中…',
    converting: '正在转换…',
    convertingPct: '正在转换… {pct}%',
    finishing: '正在完成…',
    ready: '就绪',
    readyN: '就绪（{n} 个文件）',
    failed: '失败',
    remove: '移除',
    unknown: '未知',
    downloadX: '下载 {name}',
    group_text: '文本',
    group_documents: '文档',
    group_spreadsheets: '表格',
    group_images: '图片',
    group_media: '媒体',
    'opt.txt': '纯文本 (.txt)',
    'opt.md': 'Markdown (.md)',
    'opt.html': 'HTML (.html)',
    'opt.csv': 'CSV (.csv)',
    'opt.json': 'JSON (.json)',
    'opt.jsonl': 'JSON 行 (.jsonl)',
    'opt.rtf': '富文本 (.rtf)',
    'opt.pdf': 'PDF (.pdf)',
    'opt.docx': 'Word DOCX (.docx)',
    'opt.xlsx': 'Excel XLSX (.xlsx)',
    'opt.png': 'PNG (.png)',
    'opt.jpeg': 'JPEG (.jpg)',
    'opt.webp': 'WebP (.webp)',
    'opt.svg': 'SVG (.svg)',
    'opt.gif': '从视频生成 GIF (.gif)',
    'opt.audioGeneric': '音频 {fmt} ({ext})',
    'opt.videoGeneric': '视频 {fmt} ({ext})',
    'banner.cleared': '已清除。',
    'banner.noOutputs': '尚无输出。请先转换。',
    'banner.addFirst': '请先添加一些文件。',
    'banner.doneSummary': '已完成：{s} {files}！',
    'banner.tooMuchData': '一次性数据过多（{total}）。预算 {budget}。',
    'banner.exceedsBudget': '选择总量 {total} 超出预算 {budget}。将按顺序处理。',
    'banner.triggeredDownloads': '已开始下载每个文件。',
    'banner.savedAll': '已将所有文件保存到你选择的文件夹。',
    'banner.saveCancelled': '已取消保存。',
    'banner.linkCopied': '链接已复制到剪贴板。',
    'banner.openFolderFail': '无法打开该文件夹。请重试，或在下方逐个下载。',
    couldntConvert: '无法转换：{msg}',
    unknownError: '未知错误'
  },

  ko: {
    queued: '대기 중',
    preparing: '준비 중…',
    converting: '변환 중…',
    convertingPct: '변환 중… {pct}%',
    finishing: '마무리 중…',
    ready: '완료',
    readyN: '완료 ({n}개 파일)',
    failed: '실패',
    remove: '제거',
    unknown: '알 수 없음',
    downloadX: '{name} 다운로드',
    group_text: '텍스트',
    group_documents: '문서',
    group_spreadsheets: '스프레드시트',
    group_images: '이미지',
    group_media: '미디어',
    'opt.txt': '일반 텍스트 (.txt)',
    'opt.md': 'Markdown (.md)',
    'opt.html': 'HTML (.html)',
    'opt.csv': 'CSV (.csv)',
    'opt.json': 'JSON (.json)',
    'opt.jsonl': 'JSON Lines (.jsonl)',
    'opt.rtf': '리치 텍스트 (.rtf)',
    'opt.pdf': 'PDF (.pdf)',
    'opt.docx': 'Word DOCX (.docx)',
    'opt.xlsx': 'Excel XLSX (.xlsx)',
    'opt.png': 'PNG (.png)',
    'opt.jpeg': 'JPEG (.jpg)',
    'opt.webp': 'WebP (.webp)',
    'opt.svg': 'SVG (.svg)',
    'opt.gif': '동영상에서 GIF (.gif)',
    'opt.audioGeneric': '오디오 {fmt} ({ext})',
    'opt.videoGeneric': '비디오 {fmt} ({ext})',
    'banner.cleared': '초기화했습니다.',
    'banner.noOutputs': '아직 출력이 없습니다. 먼저 변환하세요.',
    'banner.addFirst': '먼저 파일을 추가하세요.',
    'banner.doneSummary': '완료: {s} {files}!',
    'banner.tooMuchData': '한 번에 데이터가 너무 많습니다({total}). 한도 {budget}.',
    'banner.exceedsBudget': '선택한 항목의 총합 {total}이 한도 {budget}을 초과합니다. 순차적으로 처리합니다.',
    'banner.triggeredDownloads': '각 파일의 다운로드를 시작했습니다.',
    'banner.savedAll': '모든 파일을 선택한 폴더에 저장했습니다.',
    'banner.saveCancelled': '저장을 취소했습니다.',
    'banner.linkCopied': '링크가 클립보드에 복사되었습니다.',
    'banner.openFolderFail': '폴더를 열 수 없습니다. 다시 시도하거나 아래에서 개별적으로 다운로드하세요.',
    couldntConvert: '변환할 수 없습니다: {msg}',
    unknownError: '알 수 없는 오류'
  },

  hi: {
    queued: 'कतार में',
    preparing: 'तैयारी हो रही है…',
    converting: 'रूपांतरण हो रहा है…',
    convertingPct: 'रूपांतरण हो रहा है… {pct}%',
    finishing: 'समाप्ति हो रही है…',
    ready: 'तैयार',
    readyN: 'तैयार ({n} फ़ाइलें)',
    failed: 'असफल',
    remove: 'हटाएँ',
    unknown: 'अज्ञात',
    downloadX: '{name} डाउनलोड करें',
    group_text: 'टेक्स्ट',
    group_documents: 'दस्तावेज़',
    group_spreadsheets: 'स्प्रेडशीट',
    group_images: 'छवियाँ',
    group_media: 'मीडिया',
    'opt.txt': 'सादा पाठ (.txt)',
    'opt.md': 'Markdown (.md)',
    'opt.html': 'HTML (.html)',
    'opt.csv': 'CSV (.csv)',
    'opt.json': 'JSON (.json)',
    'opt.jsonl': 'JSON लाइन्स (.jsonl)',
    'opt.rtf': 'रिच टेक्स्ट (.rtf)',
    'opt.pdf': 'PDF (.pdf)',
    'opt.docx': 'Word DOCX (.docx)',
    'opt.xlsx': 'Excel XLSX (.xlsx)',
    'opt.png': 'PNG (.png)',
    'opt.jpeg': 'JPEG (.jpg)',
    'opt.webp': 'WebP (.webp)',
    'opt.svg': 'SVG (.svg)',
    'opt.gif': 'वीडियो से GIF (.gif)',
    'opt.audioGeneric': 'ऑडियो {fmt} ({ext})',
    'opt.videoGeneric': 'वीडियो {fmt} ({ext})',
    'banner.cleared': 'साफ़ किया गया।',
    'banner.noOutputs': 'अभी तक कोई परिणाम नहीं। पहले रूपांतरण करें।',
    'banner.addFirst': 'पहले कुछ फ़ाइलें जोड़ें।',
    'banner.doneSummary': 'हो गया: {s} {files}!',
    'banner.tooMuchData': 'एक साथ बहुत अधिक डेटा ({total})। बजट {budget}।',
    'banner.exceedsBudget': 'चयनित कुल {total} बजट {budget} से अधिक है। क्रमिक रूप से प्रोसेस किया जाएगा।',
    'banner.triggeredDownloads': 'प्रत्येक फ़ाइल के लिए डाउनलोड शुरू किए गए।',
    'banner.savedAll': 'सभी फ़ाइलें आपके चुने हुए फ़ोल्डर में सहेजी गईं।',
    'banner.saveCancelled': 'सेव रद्द किया गया।',
    'banner.linkCopied': 'लिंक क्लिपबोर्ड पर कॉपी किया गया।',
    'banner.openFolderFail': 'फ़ोल्डर नहीं खोला जा सका। फिर से प्रयास करें या नीचे अलग-अलग डाउनलोड करें।',
    couldntConvert: 'रूपांतरित नहीं कर सका: {msg}',
    unknownError: 'अज्ञात त्रुटि'
  },

  ar: {
    queued: 'في قائمة الانتظار',
    preparing: 'جارٍ التحضير…',
    converting: 'جارٍ التحويل…',
    convertingPct: 'جارٍ التحويل… {pct}%',
    finishing: 'جارٍ الإنهاء…',
    ready: 'جاهز',
    readyN: 'جاهز ({n} ملفًا)',
    failed: 'فشل',
    remove: 'إزالة',
    unknown: 'غير معروف',
    downloadX: 'تنزيل {name}',
    group_text: 'نص',
    group_documents: 'مستندات',
    group_spreadsheets: 'جداول بيانات',
    group_images: 'صور',
    group_media: 'وسائط',
    'opt.txt': 'نص عادي (.txt)',
    'opt.md': 'Markdown (.md)',
    'opt.html': 'HTML (.html)',
    'opt.csv': 'CSV (.csv)',
    'opt.json': 'JSON (.json)',
    'opt.jsonl': 'أسطر JSON (.jsonl)',
    'opt.rtf': 'نص منسّق (.rtf)',
    'opt.pdf': 'PDF (.pdf)',
    'opt.docx': 'Word DOCX (.docx)',
    'opt.xlsx': 'Excel XLSX (.xlsx)',
    'opt.png': 'PNG (.png)',
    'opt.jpeg': 'JPEG (.jpg)',
    'opt.webp': 'WebP (.webp)',
    'opt.svg': 'SVG (.svg)',
    'opt.gif': 'صورة GIF من فيديو (.gif)',
    'opt.audioGeneric': 'صوت {fmt} ({ext})',
    'opt.videoGeneric': 'فيديو {fmt} ({ext})',
    'banner.cleared': 'تم التنظيف.',
    'banner.noOutputs': 'لا توجد مخرجات بعد. حوِّل أولاً.',
    'banner.addFirst': 'أضِف بعض الملفات أولاً.',
    'banner.doneSummary': 'تم: {s} {files}!',
    'banner.tooMuchData': 'بيانات كثيرة دفعة واحدة ({total}). الحد {budget}.',
    'banner.exceedsBudget': 'الإجمالي المحدد {total} يتجاوز الحد {budget}. ستتم المعالجة بالتتابع.',
    'banner.triggeredDownloads': 'تم بدء التنزيلات لكل ملف.',
    'banner.savedAll': 'تم حفظ كل الملفات في المجلد الذي اخترته.',
    'banner.saveCancelled': 'تم إلغاء الحفظ.',
    'banner.linkCopied': 'تم نسخ الرابط إلى الحافظة.',
    'banner.openFolderFail': 'تعذّر فتح المجلد. حاول مجددًا أو نزّل الملفات بشكل فردي أدناه.',
    couldntConvert: 'تعذّر التحويل: {msg}',
    unknownError: 'خطأ غير معروف'
  },

  uk: {
    queued: 'У черзі',
    preparing: 'Підготовка…',
    converting: 'Перетворення…',
    convertingPct: 'Перетворення… {pct}%',
    finishing: 'Завершення…',
    ready: 'Готово',
    readyN: 'Готово ({n} файлів)',
    failed: 'Помилка',
    remove: 'Вилучити',
    unknown: 'невідомо',
    downloadX: 'Завантажити {name}',
    group_text: 'Текст',
    group_documents: 'Документи',
    group_spreadsheets: 'Таблиці',
    group_images: 'Зображення',
    group_media: 'Медіа',
    'opt.txt': 'Звичайний текст (.txt)',
    'opt.md': 'Markdown (.md)',
    'opt.html': 'HTML (.html)',
    'opt.csv': 'CSV (.csv)',
    'opt.json': 'JSON (.json)',
    'opt.jsonl': 'Рядки JSON (.jsonl)',
    'opt.rtf': 'Текст RTF (.rtf)',
    'opt.pdf': 'PDF (.pdf)',
    'opt.docx': 'Word DOCX (.docx)',
    'opt.xlsx': 'Excel XLSX (.xlsx)',
    'opt.png': 'PNG (.png)',
    'opt.jpeg': 'JPEG (.jpg)',
    'opt.webp': 'WebP (.webp)',
    'opt.svg': 'SVG (.svg)',
    'opt.gif': 'GIF з відео (.gif)',
    'opt.audioGeneric': 'Аудіо {fmt} ({ext})',
    'opt.videoGeneric': 'Відео {fmt} ({ext})',
    'banner.cleared': 'Очищено.',
    'banner.noOutputs': 'Ще немає результатів. Спочатку виконайте конвертацію.',
    'banner.addFirst': 'Спочатку додайте файли.',
    'banner.doneSummary': 'Готово: {s} {files}!',
    'banner.tooMuchData': 'Забагато даних одночасно ({total}). Бюджет {budget}.',
    'banner.exceedsBudget': 'Загальний вибраний обсяг {total} перевищує бюджет {budget}. Обробка відбуватиметься послідовно.',
    'banner.triggeredDownloads': 'Запущено завантаження для кожного файлу.',
    'banner.savedAll': 'Усі файли збережено у вибрану теку.',
    'banner.saveCancelled': 'Збереження скасовано.',
    'banner.linkCopied': 'Посилання скопійовано до буфера обміну.',
    'banner.openFolderFail': 'Не вдалося відкрити теку. Спробуйте ще раз або завантажуйте окремо нижче.',
    couldntConvert: 'Не вдалося конвертувати: {msg}',
    unknownError: 'Невідома помилка'
  },

  tr: {
    queued: 'Kuyrukta',
    preparing: 'Hazırlanıyor…',
    converting: 'Dönüştürülüyor…',
    convertingPct: 'Dönüştürülüyor… {pct}%',
    finishing: 'Tamamlanıyor…',
    ready: 'Hazır',
    readyN: 'Hazır ({n} dosya)',
    failed: 'Başarısız',
    remove: 'Kaldır',
    unknown: 'bilinmiyor',
    downloadX: '{name} dosyasını indir',
    group_text: 'Metin',
    group_documents: 'Belgeler',
    group_spreadsheets: 'Elektronik tablolar',
    group_images: 'Görseller',
    group_media: 'Medya',
    'opt.txt': 'Düz metin (.txt)',
    'opt.md': 'Markdown (.md)',
    'opt.html': 'HTML (.html)',
    'opt.csv': 'CSV (.csv)',
    'opt.json': 'JSON (.json)',
    'opt.jsonl': 'JSON Satırları (.jsonl)',
    'opt.rtf': 'Zengin Metin (.rtf)',
    'opt.pdf': 'PDF (.pdf)',
    'opt.docx': 'Word DOCX (.docx)',
    'opt.xlsx': 'Excel XLSX (.xlsx)',
    'opt.png': 'PNG (.png)',
    'opt.jpeg': 'JPEG (.jpg)',
    'opt.webp': 'WebP (.webp)',
    'opt.svg': 'SVG (.svg)',
    'opt.gif': 'Videodan GIF (.gif)',
    'opt.audioGeneric': 'Ses {fmt} ({ext})',
    'opt.videoGeneric': 'Video {fmt} ({ext})',
    'banner.cleared': 'Temizlendi.',
    'banner.noOutputs': 'Henüz çıktı yok. Önce dönüştürün.',
    'banner.addFirst': 'Önce birkaç dosya ekleyin.',
    'banner.doneSummary': 'Bitti: {s} {files}!',
    'banner.tooMuchData': 'Aynı anda çok fazla veri ({total}). Bütçe {budget}.',
    'banner.exceedsBudget': 'Seçili toplam {total}, {budget} bütçesini aşıyor. Sırayla işlenecek.',
    'banner.triggeredDownloads': 'Her dosya için indirmeler başlatıldı.',
    'banner.savedAll': 'Tüm dosyalar seçtiğiniz klasöre kaydedildi.',
    'banner.saveCancelled': 'Kaydetme iptal edildi.',
    'banner.linkCopied': 'Bağlantı panoya kopyalandı.',
    'banner.openFolderFail': 'Klasör açılamadı. Yeniden deneyin veya aşağıdan tek tek indirin.',
    couldntConvert: 'Dönüştürülemedi: {msg}',
    unknownError: 'Bilinmeyen hata'
  },

  nl: {
    queued: 'In de wachtrij',
    preparing: 'Voorbereiden…',
    converting: 'Bezig met converteren…',
    convertingPct: 'Converteren… {pct}%',
    finishing: 'Bezig met afronden…',
    ready: 'Klaar',
    readyN: 'Klaar ({n} bestanden)',
    failed: 'Mislukt',
    remove: 'Verwijderen',
    unknown: 'onbekend',
    downloadX: '{name} downloaden',
    group_text: 'Tekst',
    group_documents: 'Documenten',
    group_spreadsheets: 'Spreadsheets',
    group_images: 'Afbeeldingen',
    group_media: 'Media',
    'opt.txt': 'Platte tekst (.txt)',
    'opt.md': 'Markdown (.md)',
    'opt.html': 'HTML (.html)',
    'opt.csv': 'CSV (.csv)',
    'opt.json': 'JSON (.json)',
    'opt.jsonl': 'JSON-regels (.jsonl)',
    'opt.rtf': 'RTF-tekst (.rtf)',
    'opt.pdf': 'PDF (.pdf)',
    'opt.docx': 'Word DOCX (.docx)',
    'opt.xlsx': 'Excel XLSX (.xlsx)',
    'opt.png': 'PNG (.png)',
    'opt.jpeg': 'JPEG (.jpg)',
    'opt.webp': 'WebP (.webp)',
    'opt.svg': 'SVG (.svg)',
    'opt.gif': 'GIF uit video (.gif)',
    'opt.audioGeneric': 'Audio {fmt} ({ext})',
    'opt.videoGeneric': 'Video {fmt} ({ext})',
    'banner.cleared': 'Leeggemaakt.',
    'banner.noOutputs': 'Nog geen uitvoer. Converteer eerst.',
    'banner.addFirst': 'Voeg eerst wat bestanden toe.',
    'banner.doneSummary': 'Klaar: {s} {files}!',
    'banner.tooMuchData': 'Te veel data in één keer ({total}). Budget {budget}.',
    'banner.exceedsBudget': 'Totaal geselecteerd {total} overschrijdt budget {budget}. Wordt sequentieel verwerkt.',
    'banner.triggeredDownloads': 'Downloads gestart voor elk bestand.',
    'banner.savedAll': 'Alle bestanden opgeslagen in de gekozen map.',
    'banner.saveCancelled': 'Opslaan geannuleerd.',
    'banner.linkCopied': 'Link naar klembord gekopieerd.',
    'banner.openFolderFail': 'Map kon niet worden geopend. Probeer opnieuw of download afzonderlijk hieronder.',
    couldntConvert: 'Kon niet converteren: {msg}',
    unknownError: 'Onbekende fout'
  }
};


(function initI18N() {
  const htmlLang = (document.documentElement.lang || 'en').trim();
  const norm = htmlLang.toLowerCase();
  const LANG_ALIAS = {
    'pt-br': 'pt-BR', 'pt_pt': 'pt',
    'zh': 'zh-CN', 'zh-hans': 'zh-CN', 'zh-cn': 'zh-CN',
    'he': 'ar' // generic RTL fallback
  };
  const lang = (() => {
    if (I18N[htmlLang]) return htmlLang;
    if (I18N[norm]) return norm;
    if (I18N[LANG_ALIAS[norm]]) return LANG_ALIAS[norm];
    const base = norm.split('-')[0];
    return I18N[base] ? base : 'en';
  })();
  window.APP_LANG = lang;
  function fmt(s, vars) {
    return String(s).replace(/\{(\w+)\}/g, (_, k) => (vars && k in vars) ? vars[k] : '{' + k + '}');
  }

  // Translator
  window.t = function t(key, vars) {
    const pack = I18N[lang] || I18N.en;
    const s = (pack[key] ?? I18N.en[key] ?? key);
    return fmt(s, vars);
  };

  // Build option labels without inflating the dictionary
  window.optLabel = function optLabel(val) {
    const simple = {
      txt: 'opt.txt', md: 'opt.md', html: 'opt.html', csv: 'opt.csv',
      json: 'opt.json', jsonl: 'opt.jsonl', rtf: 'opt.rtf',
      pdf: 'opt.pdf', docx: 'opt.docx', xlsx: 'opt.xlsx',
      png: 'opt.png', jpeg: 'opt.jpeg', webp: 'opt.webp', svg: 'opt.svg',
      gif: 'opt.gif'
    };
    if (simple[val]) return t(simple[val]);
    if (['mp3', 'wav', 'ogg', 'm4a'].includes(val)) return t('opt.audioGeneric', { fmt: val.toUpperCase(), ext: '.' + val });
    if (['mp4', 'webm'].includes(val)) return t('opt.videoGeneric', { fmt: val.toUpperCase(), ext: '.' + val });
    return val.toUpperCase() + ' (.' + val + ')';
  };

  // Intercept showBanner to translate & render; hide technical noise
  const _show = (typeof window.showBanner === 'function') ? window.showBanner : null;

  function isTechnicalMessage(m) {
    const s = String(m || '');
    return (
      /^\[(diag|tech)\]/i.test(s) ||
      /\bffmpeg\b/i.test(s) ||
      /\bwasm\b/i.test(s) ||
      /\bcontent[- ]type\b/i.test(s) ||
      /\bcrossOriginIsolated\b/i.test(s) ||
      /\bCSP\b/i.test(s)
    );
  }

  window.showBanner = function (msg, kind = 'info') {
    try {
      let m = String(msg);

      // Map a few English fallbacks to i18n keys
      if (m === 'Cleared.') m = t('banner.cleared');
      else if (m === 'No outputs yet. Convert first.') m = t('banner.noOutputs');
      else if (m === 'Add some files first.') m = t('banner.addFirst');

      // Normalize "Done ..." English into i18n
      const done = m.match(/\bDone\.\s+(\d+)\s+succeeded\b/i);
      if (done) {
        const s = parseInt(done[1], 10) || 0;
        const f = (m.match(/,\s*(\d+)\s+failed/i) ? parseInt(RegExp.$1, 10) : 0) || 0;
        const L = window.APP_LANG || 'en';
        if (f === 0) {
          tb('banner.doneOk', { s, files: wordFiles(s, L) });       // ✅ green
        } else if (s > 0) {
          tb('banner.finishedMixed', { s, files: wordFiles(s, L), f });    // ❌ red
        } else {
          tb('banner.finishedFail', { f, files: wordFiles(f, L) });       // ❌ red
        }

        const filesS = wordFiles(s, L), filesF = wordFiles(f, L);
        if (f > 0 && s === 0) m = t('banner.doneFail', { f, files: filesF });
        else if (f > 0) m = t('banner.doneMixed', { s, files: filesS, f });
        else m = t('banner.doneOk', { s, files: filesS });
      }

      // Quiet technical noise
      if (window.QUIET_TECH && isTechnicalMessage(m)) {
        if (window.DEBUG_CONVERTER) console[kind === 'error' ? 'error' : 'log']('[tech]', m);
        return;
      }

      // Call prior impl for compatibility, but DO NOT return early
      if (_show) { try { _show(m, kind); } catch { } }

      // Write into the small banner line
      const el = document.getElementById('banner');
      if (el) {
        el.textContent = m;
        el.classList.toggle('error', kind === 'error');
        el.classList.toggle('ok', kind === 'ok');
        el.hidden = false;
      }
    } catch (e) {
      if (_show) return _show(msg, kind);
      console[kind === 'error' ? 'error' : 'log'](msg);
    }
  };
})(); // ← close block and invoke it


function loadScript(url) {
  return new Promise((res, rej) => {
    const s = document.createElement('script');
    s.src = url; s.onload = () => res(); s.onerror = () => rej(new Error('load ' + url));
    document.head.appendChild(s);
  });
}
const CDN = {

  pdf: ['/vendor/pdf.min.js', 'https://unpkg.com/pdfjs-dist@4/legacy/build/pdf.min.js'],
  pdfWorker: ['/vendor/pdf.worker.min.js', 'https://unpkg.com/pdfjs-dist@4/legacy/build/pdf.worker.min.js'],

  mammoth: ['/vendor/mammoth.browser.min.js', 'https://unpkg.com/mammoth/mammoth.browser.min.js'],
  xlsx: ['/vendor/xlsx.full.min.js', 'https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js'],
  jszip: ['/vendor/jszip.min.js', 'https://cdn.jsdelivr.net/npm/jszip/dist/jszip.min.js'],
  tesseract: ['/vendor/tesseract.min.js', 'https://cdn.jsdelivr.net/npm/tesseract.js/dist/tesseract.min.js'],
  jspdf: ['/vendor/jspdf.umd.min.js', 'https://cdn.jsdelivr.net/npm/jspdf/dist/jspdf.umd.min.js'],
  docx: ['/vendor/docx.min.js', 'https://cdn.jsdelivr.net/npm/docx/build/index.min.js'],
  ffmpeg: ['/vendor/ffmpeg/ffmpeg.min.js', 'https://unpkg.com/@ffmpeg/ffmpeg@0.12.10/dist/umd/ffmpeg.js'],
  ffmpegCore: ['/vendor/ffmpeg/ffmpeg-core.js', 'https://unpkg.com/@ffmpeg/core@0.12.10/dist/umd/ffmpeg-core.js'],
};
async function loadScriptTry(localUrl, cdnUrl) {
  try { await loadScript(localUrl); }
  catch { console.warn('Local missing, using CDN:', cdnUrl); await loadScript(cdnUrl); }
}
// spread the NodeList correctly
function loadedSrcContains(substr) {
  const s = [...document.querySelectorAll('script[src]')].map(n => n.src);
  return s.find(u => u.includes(substr));
}

let ffmpegInstance = null;


// needFFmpeg(): cross-browser loader with MT (if isolated) and ST fallback
// Robust FFmpeg loader: CDN wrapper, normalize globals, MT when isolated, ST fallback
// Robust FFmpeg loader: LOCAL wrapper -> CDN fallback, MT when isolated, ST fallback
async function needFFmpeg() {
  if (window.__ffmpeg?.loaded || window.__ffmpeg?.isLoaded?.()) return window.__ffmpeg;

  const VER = '0.12.10';

  // 1) Wrapper candidates (LOCAL first to avoid cross-origin Worker error)
  const WRAPPERS = [
    '/vendor/ffmpeg/ffmpeg.min.js',                                                  // ← local official UMD (0.12.10)
    `https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@${VER}/dist/umd/ffmpeg.js`,
    `https://unpkg.com/@ffmpeg/ffmpeg@${VER}/dist/umd/ffmpeg.js`
  ];

  // 2) Cores (UMD). Use MT only when SharedArrayBuffer is allowed
  const CORE_ST = `https://unpkg.com/@ffmpeg/core@${VER}/dist/umd/ffmpeg-core.js`;
  const CORE_MT = `https://unpkg.com/@ffmpeg/core-mt@${VER}/dist/umd/ffmpeg-core.js`;
  const useMT = !!window.crossOriginIsolated;
  const coreURL = useMT ? CORE_MT : CORE_ST;
  const wasmURL = coreURL.replace(/\.js$/, '.wasm');
  const workerURL = coreURL.replace(/\.js$/, '.worker.js');

  const loadScript = (src) => new Promise((resolve, reject) => {
    const s = document.createElement('script');
    s.src = src; s.async = true; s.crossOrigin = 'anonymous';
    s.onload = () => queueMicrotask(resolve);
    s.onerror = () => reject(new Error('Failed to load ' + src));
    document.head.appendChild(s);
  });

  const pickApi = () => {
    if (window.FFmpeg?.FFmpeg || window.FFmpeg?.createFFmpeg) {
      return { ns: window.FFmpeg, hasClass: !!window.FFmpeg.FFmpeg, hasFactory: !!window.FFmpeg.createFFmpeg };
    }
    if (window.FFmpegWASM?.FFmpeg || window.FFmpegWASM?.createFFmpeg) {
      window.FFmpeg = window.FFmpegWASM; // normalize
      return { ns: window.FFmpegWASM, hasClass: !!window.FFmpegWASM.FFmpeg, hasFactory: !!window.FFmpegWASM.createFFmpeg };
    }
    return null;
  };

  let api = pickApi();
  for (const url of (!api ? WRAPPERS : [])) {
    try {
      console.log('[FFmpeg wrapper] loading', url);
      await loadScript(url);
      api = pickApi();
      if (api) break;
    } catch (e) {
      console.warn('[FFmpeg wrapper] failed', url, e);
    }
  }
  if (!api) {
    console.error('[FFmpeg] diagnostics: crossOriginIsolated=', window.crossOriginIsolated);
    throw new Error('FFmpeg UMD wrapper failed to load');
  }

  let ff;
  if (api.hasClass) ff = new api.ns.FFmpeg();              // 0.12 class
  else if (api.hasFactory) ff = api.ns.createFFmpeg();     // legacy factory
  else throw new Error('FFmpeg wrapper exposes neither class nor factory');

  // ---- replace your onProgress handler with this ----
  const onProgress = (payload = {}) => {
    // 0.12 sends {progress: 0..1, time, fps, ...}; older sends {ratio: 0..1}
    let val = Number.isFinite(payload.progress) ? payload.progress
      : Number.isFinite(payload.ratio) ? payload.ratio
        : 0;

    // clamp and sanitize
    if (!Number.isFinite(val)) val = 0;
    if (val < 0) val = 0;
    if (val > 1) val = 1;

    const pct = Math.round(val * 100);
    console.log('[ffmpeg] progress', pct + '%');

    const g = document.getElementById('global-ffmpeg-progress');
    if (g && 'value' in g) g.value = pct;
  };
  // wire it (keep both models)
  if (typeof ff.on === 'function') {
    ff.on('progress', onProgress);
    ff.on('log', ({ type, message }) => {
      if (type === 'info' || type === 'fferr' || type === 'ffout') console.log('[ffmpeg]', type, message);
    });
  } else if (typeof ff.setProgress === 'function') {
    ff.setProgress(onProgress);
  }

  if (typeof ff.on === 'function') {
    ff.on('log', ({ type, message }) => {
      if (type === 'info' || type === 'fferr' || type === 'ffout') console.log('[ffmpeg]', type, message);
    });
    ff.on('progress', onProgress);
  } else if (typeof ff.setProgress === 'function') {
    ff.setProgress(onProgress);
  }

  if (typeof ff.load === 'function') {
    await ff.load({
      log: true,
      coreURL: coreURL,
      wasmURL: wasmURL,
      workerURL: workerURL
    });
  } else {
    // ancient factory fallback
    ff = api.ns.createFFmpeg({ log: true, corePath: coreURL });
    await ff.load();
  }

  if (!window.fetchFile && api.ns?.fetchFile) window.fetchFile = api.ns.fetchFile;

  window.__ffmpeg = ff;
  return ff;
}





(function prewarmFFmpeg() {
  const kick = () => { try { needFFmpeg(); } catch { } window.removeEventListener('pointerdown', kick); };
  if ('requestIdleCallback' in window) requestIdleCallback(() => { try { needFFmpeg(); } catch { } });
  window.addEventListener('pointerdown', kick, { once: true });
})();





// app.js — detect-only vendor check
// Copy–paste this whole function
async function ensureVendors() {
  // --- feature detection ---
  features.pdf = !!window.pdfjsLib;
  features.docx = !!window.mammoth;
  features.xlsx = !!window.XLSX;
  features.pptx = !!window.JSZip;
  features.ocr = !!window.Tesseract;
  features.makePdf = !!(window.jspdf && window.jspdf.jsPDF);
  features.makeDocx = !!window.docx;
  features.ffmpeg = !!(window.FFmpeg && (window.FFmpeg.createFFmpeg || window.FFmpeg.FFmpeg));

  // tiny banner helper — respect QUIET_TECH
  const show = (msg, kind = 'info') => {
    if (window.QUIET_TECH && !window.DEBUG_CONVERTER) {
      // In quiet mode, keep diagnostics out of the UI
      return console[kind === 'error' ? 'error' : 'log']('[diag]', msg);
    }
    if (typeof showBanner === 'function') return showBanner(msg, kind);
    console[kind === 'error' ? 'error' : 'log'](msg);
  };


  // --- on-demand FFmpeg diagnostics (scoped to this function) ---
  async function diagnoseFFmpeg() {
    const issues = [];
    const checks = [];

    const headOrGet = async (url) => {
      const common = { cache: 'no-store', redirect: 'follow' };
      try {
        let r = await fetch(url, { method: 'HEAD', ...common });
        if (!r.ok && r.status === 405) r = await fetch(url, { method: 'GET', ...common });
        return { url, ok: r.ok, status: r.status, ct: r.headers.get('content-type') || '' };
      } catch (e) {
        return { url, ok: false, status: 0, error: (e && e.message) || String(e) };
      }
    };

    if (location.protocol === 'file:') {
      issues.push('Running over file:// — serve the site via http(s) so the browser can fetch WASM.');
    }

    // Wrapper present?
    const wrapperTag = [...document.querySelectorAll('script[src]')].find(s => /(^|\/)ffmpeg\.js(\?|$)/.test(s.src));
    const wrapperHasGlobal = !!(window.FFmpeg && window.FFmpeg.createFFmpeg);
    if (!wrapperTag) issues.push('ffmpeg.js (wrapper) <script> not found.');
    if (wrapperTag && !wrapperHasGlobal) issues.push('ffmpeg.js loaded but window.FFmpeg.createFFmpeg is unavailable (CSP/namespace?).');

    // Candidate core URLs (local → any script we see → common CDNs)
    const candidates = new Set();
    candidates.add('/vendor/ffmpeg/ffmpeg-core.js');
    const scriptCore = [...document.querySelectorAll('script[src]')]
      .map(s => s.src).filter(src => /ffmpeg-core\.js(\?|$)/.test(src));
    scriptCore.forEach(u => candidates.add(u));
    candidates.add('https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.10/dist/umd/ffmpeg-core.js');
    candidates.add('https://unpkg.com/@ffmpeg/core@0.12.10/dist/umd/ffmpeg-core.js');

    // Probe cores until one responds OK
    let core = null;
    for (const url of candidates) {
      const res = await headOrGet(url); checks.push(res);
      if (res.ok) { core = res; break; }
    }
    if (!core) {
      issues.push('ffmpeg-core.js not reachable (local missing and CDNs blocked?).');
    }

    // Probe WASM next to the chosen core (or the local path if none worked)
    const wasmUrl = (core ? core.url : '/vendor/ffmpeg/ffmpeg-core.js').replace(/\.js(\?.*)?$/, '.wasm');
    const wasm = await headOrGet(wasmUrl); checks.push(wasm);
    if (!wasm.ok) {
      issues.push('ffmpeg-core.wasm not found next to ffmpeg-core.js.');
    } else if (wasm.ct && !/application\/wasm/i.test(wasm.ct)) {
      issues.push('ffmpeg-core.wasm served with wrong Content-Type (should be application/wasm).');
    }

    // Info (not fatal for UMD)
    if (!crossOriginIsolated) {
      console.info('FFmpeg note: crossOriginIsolated=false → threads/SIMD may be disabled (OK for basic usage).');
    }

    console.groupCollapsed('[FFmpeg] diagnostics');
    checks.forEach(c => console.log(c));
    console.groupEnd();

    const msg = issues.length
      ? 'FFmpeg not ready: ' + issues[0]
      : 'FFmpeg wrapper present and core/WASM look reachable.';
    show(msg, issues.length ? 'error' : 'ok');

    return { issues, checks };
  }

  // --- render capability list (simple labels, no library names) ---
  // --- render capability list (simple labels, no library names) ---
  const caps = document.querySelector('#caps');
  if (caps) {
    caps.innerHTML = '';

    // During the grace window, treat all as green unless truly detected red later
    const inGrace = Date.now() < (window.__capGraceUntil || 0);

    const CAP_LIST = [
      ['Images', true],                     // built-in client rendering
      ['PDF', features.pdf],
      ['Word (DOCX)', features.docx],
      ['Excel (XLSX)', features.xlsx],
      ['ZIP', features.pptx],
      ['OCR', features.ocr],
      ['Make PDF', features.makePdf],
      ['Make DOCX', features.makeDocx],
      ['Media', features.ffmpeg],           // FFmpeg.wasm
    ];

    CAP_LIST.forEach(([label, ok]) => {
      const row = document.createElement('div');

      // optimistic green while in grace window
      const green = ok || inGrace;

      row.className = 'cap ' + (green ? 'ok' : 'miss');
      row.textContent = (green ? '✓ ' : '⨯ ') + label;

      // Only after grace window, let users click "Media" to diagnose when actually red
      if (!inGrace && label === 'Media' && !ok) {
        row.title = 'Click to run a quick check (console only)';
        row.style.cursor = 'pointer';
        row.addEventListener('click', () => {
          const oldShow = window.showBanner;
          if (!window.DEBUG_CONVERTER) {
            window.showBanner = (m, t) => console[(t === 'error') ? 'error' : 'log']('[diag]', m);
          }
          diagnoseFFmpeg().finally(() => { window.showBanner = oldShow; });
        });
      }

      caps.append(row);
    });
  }


  // --- do NOT auto-run FFmpeg diagnostics or auto-show errors in quiet mode ---
  // do NOT auto-run FFmpeg diagnostics or auto-show errors in quiet mode
  if (!features.ffmpeg && !window.DEBUG_CONVERTER) {
    // keep it quiet
  } else if (!features.ffmpeg && window.DEBUG_CONVERTER) {
    setTimeout(() => diagnoseFFmpeg().catch(() => { }), 0);
  }


  // Optional: expose for DevTools
  window.diagnoseFFmpeg = diagnoseFFmpeg;

  return features;

}
// --- Row progress helpers (paste once) ---

// app.js — replace your existing setRowProgress with this version
function setRowProgress(index, frac = 0) {
  // sanitize & clamp
  if (!Number.isFinite(frac)) frac = 0;
  if (frac < 0) frac = 0;
  if (frac > 1) frac = 1;
  const pct = Math.round(frac * 100);

  // elements
  const pr = document.getElementById('prog-' + index);
  const st = document.getElementById('status-' + index);
  const list = document.getElementById('file-list');
  const card = list ? list.children[index] : null;

  if (pr && 'value' in pr) pr.value = pct;

  // constant label during conversion; switch at completion
  if (st) st.textContent = (pct >= 100 ? t('finishing') : t('converting'));

  // class drives the CSS base width used while converting
  if (card) {
    if (pct >= 100) card.classList.remove('is-converting');
    else card.classList.add('is-converting');
  }

  // measure status width so CSS can subtract it exactly
  if (card && st) {
    const w = Math.ceil(st.getBoundingClientRect().width);
    card.style.setProperty('--status-w', w + 'px');
  }

  if (window.sizeProgress && card) window.sizeProgress(card);
}


/** Convenience: show some coarse steps for libraries that don't expose granular progress. */
function stepper(index, steps = [
  [t('preparing'), 0.10],
  [t('processing'), 0.50],
  [t('encoding'), 0.90],
]) {
  let i = 0;
  return {
    next() {
      if (i < steps.length) {
        const [label, frac] = steps[i++];
        setRowProgress(index, frac, label);
      }
    },
    done() {
      setRowProgress(index, 1, t('finishing'));
      const card = document.getElementById('file-list')?.children[index];
      if (card) card.classList.remove('is-converting');
    }
  };
}

// --- FFmpeg diagnostics (paste once) ---
async function diagnoseFFmpeg() {
  const issues = [];
  const checks = [];
  const show = (msg, kind = 'info') => (typeof showBanner === 'function' ? showBanner(msg, kind) : console[kind === 'error' ? 'error' : 'log'](msg));

  const headOrGet = async (url) => {
    try {
      let r = await fetch(url, { method: 'HEAD', cache: 'no-store' });
      if (!r.ok && r.status === 405) r = await fetch(url, { method: 'GET', cache: 'no-store' });
      return { url, ok: r.ok, status: r.status, ct: r.headers.get('content-type') || '' };
    } catch (e) {
      return { url, ok: false, status: 0, error: (e && e.message) || String(e) };
    }
  };

  if (location.protocol === 'file:') {
    issues.push('Running over file:// — serve via http(s) so the browser can fetch WASM.');
  }

  // Wrapper presence + MIME sanity
  const wrapperSrc =
    ([...document.querySelectorAll('script[src]')].map(s => s.src).find(s => /(^|\/)ffmpeg\.js(\?|$)/.test(s)) ||
      '/vendor/ffmpeg/ffmpeg.min.js');
  const wrap = await headOrGet(wrapperSrc); checks.push(wrap);
  const wrapperHasGlobal = !!(window.FFmpeg && window.FFmpeg.createFFmpeg);
  if (!wrap.ok) issues.push('ffmpeg.js (wrapper) not reachable.');
  if (wrap.ok && wrap.ct && !/javascript|ecmascript/i.test(wrap.ct)) {
    issues.push('ffmpeg.js served as ' + wrap.ct + ' (often an HTML fallback).');
  }
  if (wrap.ok && !wrapperHasGlobal) {
    issues.push('ffmpeg.js loaded but window.FFmpeg.createFFmpeg is missing (wrong build/CSP?).');
  }

  // Core + WASM
  const coreCandidates = [
    '/vendor/ffmpeg/ffmpeg-core.js',
    ...[...document.querySelectorAll('script[src]')].map(s => s.src).filter(src => /ffmpeg-core\.js(\?|$)/.test(src)),
    `https://cdn.jsdelivr.net/npm/@ffmpeg/core@${FFMPEG_VER}/dist/umd/ffmpeg-core.js`,
    `https://unpkg.com/@ffmpeg/core@${FFMPEG_VER}/dist/umd/ffmpeg-core.js`,
  ];
  let core = null;
  for (const url of coreCandidates) {
    const res = await headOrGet(url); checks.push(res);
    if (res.ok) { core = res; break; }
  }
  if (!core) issues.push('ffmpeg-core.js not reachable (local missing and CDNs blocked?).');

  const wasmUrl = (core ? core.url : coreCandidates[0]).replace(/\.js(\?.*)?$/, '.wasm');
  const wasm = await headOrGet(wasmUrl); checks.push(wasm);
  if (!wasm.ok) issues.push('ffmpeg-core.wasm not found next to ffmpeg-core.js.');
  if (wasm.ok && wasm.ct && !/application\/wasm/i.test(wasm.ct)) {
    issues.push('ffmpeg-core.wasm served with wrong Content-Type; should be application/wasm.');
  }

  if (!crossOriginIsolated) {
    console.info('FFmpeg note: crossOriginIsolated=false → threads/SIMD may be disabled (OK for basic usage).');
  }

  console.groupCollapsed('[FFmpeg] diagnostics');
  checks.forEach(c => console.log(c));
  console.groupEnd();

  const msg = issues.length ? 'FFmpeg not ready: ' + issues[0] : 'FFmpeg wrapper present and core/WASM look reachable.';
  show(msg, issues.length ? 'error' : 'ok');
  return { issues, checks };
}

// expose for manual use in console
window.diagnoseFFmpeg = diagnoseFFmpeg;

function registerOutputs(index, outs, runId, target) {
  if (isStale(runId)) return;

  state.outputsByFile[index] = outs.map(o => ({
    name: o.name,
    blob: o.blob,
    url: URL.createObjectURL(o.blob)
  }));

  const card = document.getElementById('file-list')?.children[index];
  if (card) {
    const nameEl = card.querySelector('.f-name');
    const status = card.querySelector('#status-' + index);
    const pr = document.getElementById('prog-' + index);
    const badgeEl = card.querySelector('.badge');

    const newLabel = displayNameForOutputs(state.files[index], outs, target);
    if (nameEl) {
      nameEl.classList.add('clickable');
      nameEl.setAttribute('tabindex', '0');
      nameEl.setAttribute('role', 'button');
      nameEl.setAttribute('aria-disabled', 'false');
      nameEl.title = newLabel;
      nameEl.innerHTML = `<strong>${newLabel}</strong>`;
    }

    if (badgeEl) badgeEl.textContent = badgeForOutputs(outs, target);

    if (status) status.textContent = outs.length > 1 ? t('readyN', { n: outs.length }) : t('ready');
    if (pr) pr.value = 100;

    card.classList.remove('is-converting');

    // 🔧 ensure the row still fits on one line after text changes
    if (window.sizeProgress) window.sizeProgress(card);

  }
}


function createFileCard(index, file, badgeText = '', statusText = t('queued')) {
  const card = document.createElement('div');
  card.className = 'filecard is-converting';

  const typeLabel = file.type || t('unknown');
  card.innerHTML = `
    <div class="file-meta">
      <div class="f-name" title="${file.name}" aria-disabled="true">
        <strong>${file.name}</strong>
      </div>
      <div class="sub">${fmtBytes(file.size)} • ${typeLabel}</div>
    </div>

    <div class="file-controls">
      <div class="badge">${badgeText}</div>
      <progress class="file-progress" id="prog-${index}" max="100" value="0"></progress>
      <div class="status" id="status-${index}">${statusText}</div>
      <button type="button" class="file-remove" data-index="${index}" aria-label="${t('remove')} ${file.name}" title="${t('remove')}">×</button>
    </div>
  `;

  // remove button
  card.querySelector('.file-remove').addEventListener('click', (e) => {
    const i = +e.currentTarget.dataset.index;
    card.remove();
    // also remove from app state if you keep one (e.g., files.splice(i,1))
  });

  return card;
}

// one-time: click on the filename downloads its outputs (when ready)
document.addEventListener('DOMContentLoaded', () => {
  const list = document.getElementById('file-list');
  if (!list) return;
  const tagAll = (root) => {
    root.querySelectorAll('progress:not(.file-progress)').forEach(p => {
      p.classList.add('file-progress');
    });
  };
  tagAll(list);

  // observe for newly added file cards/progress bars
  const mo = new MutationObserver((mutations) => {
    for (const m of mutations) {
      m.addedNodes.forEach((n) => {
        if (n.nodeType !== 1) return;                    // elements only
        if (n.tagName === 'PROGRESS') {                  // a progress itself
          n.classList.add('file-progress');
        } else {                                         // a card subtree
          tagAll(n);
        }
      });
    }
  });
  mo.observe(list, { childList: true, subtree: true });
  // Click to download (only after conversion)
  list.addEventListener('click', (e) => {
    const nameEl = e.target.closest('.f-name');
    if (!nameEl || !nameEl.classList.contains('clickable')) return; // block pre-conversion
    const card = nameEl.closest('.filecard');
    const index = [...list.children].indexOf(card);
    if (index < 0) return;
    if (state.outputsByFile[index]?.length) downloadOutputs(index);
  });

  // Keyboard support (Enter/Space) when clickable
  list.addEventListener('keydown', (e) => {
    if (!e.target.classList?.contains('f-name')) return;
    if (!e.target.classList.contains('clickable')) return; // block pre-conversion
    if (e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      const card = e.target.closest('.filecard');
      const index = [...list.children].indexOf(card);
      if (index >= 0 && state.outputsByFile[index]?.length) downloadOutputs(index);
    }
  });
  // Show capabilities as green by default for the first 3 seconds
  window.__capGraceUntil = Date.now() + 3000;

  // Initial optimistic render (badges appear green right away)
  try { typeof ensureVendors === 'function' && ensureVendors(); } catch { }

  // After grace window, re-run detection and render for real
  setTimeout(() => { try { typeof ensureVendors === 'function' && ensureVendors(); } catch { } }, 3000);

  // ---- Non-blocking vendor warmups so badges flip to green on load ----
  const idle = window.requestIdleCallback || ((fn) => setTimeout(fn, 0));
  idle(() => {
    const warmups = [];

    const tryWarm = (fn) => {
      try {
        const p = fn?.();
        if (p && typeof p.then === 'function') warmups.push(p.catch(() => { }));
      } catch { /* ignore */ }
    };

    // Only call if these helpers exist in your app:
    tryWarm(typeof needPdf === 'function' ? () => needPdf() : null);
    tryWarm(typeof warmFFmpegWrapper === 'function' ? () => warmFFmpegWrapper() : null);

    // (Optional) warm others too:
    // tryWarm(typeof needXLSX === 'function' ? () => needXLSX() : null);
    // tryWarm(typeof needJSZip === 'function' ? () => needJSZip() : null);
    // tryWarm(typeof needJsPDF === 'function' ? () => needJsPDF() : null);
    // tryWarm(typeof needDocx === 'function' ? () => needDocx() : null);

    Promise.allSettled(warmups).then(() => {
      try { typeof ensureVendors === 'function' && ensureVendors(); } catch { }
    });
  });
});


function downloadOutputs(index) {
  const outs = state.outputsByFile[index] || [];
  if (!outs.length) return;

  (async () => {
    for (const o of outs) {
      const a = document.createElement('a');
      a.href = o.url;
      a.download = o.name;
      document.body.appendChild(a);
      a.click();
      a.remove();
      await new Promise(r => setTimeout(r, 120));
    }
  })();
}

/* ========= 4) State & element refs ========= */
const state = { files: [], outputs: [], outputsByFile: {}, budget: estimateSafeBudgetBytes(), useAuto: true, runId: 0 };

const isStale = (rid) => rid !== state.runId;


const memoryPill = $('#memory-pill'); const limitMode = $('#limit-mode'); const manualLimit = $('#manual-limit');
const targetFormat = $('#target-format'); const qualityWrap = $('#quality-wrap'); const quality = $('#quality');
const fileInput = $('#file-input'); const dropzone = $('#dropzone'); const fileList = $('#file-list'); const banner = $('#banner');
const convertBtn = $('#convert-btn'); const saveAllBtn = $('#save-all-btn'); const downloads = $('#downloads'); const downloadLinks = $('#download-links');

function refreshMemoryPill() {
  if (!memoryPill) return;               // <— guard
  const mode = state.useAuto ? 'Auto' : 'Manual';
  const mb = Math.round(state.budget / 1048576);
  memoryPill.innerHTML = `<strong>Memory:</strong> <small>${mode}</small> <span>•</span> <span>${mb} MB</span>`;
}

// --- Quiet UI config ---
window.DEBUG_CONVERTER = window.DEBUG_CONVERTER ?? false;  // keep console debug off in prod
const QUIET_UI = false;       // suppress scary banners for end users
const SHOW_ERRORS_AS_TOAST = false; // set true if you want a subtle visible error line instead of full suppression

function showBanner(msg, tone = 'info') {
  // In quiet mode, don't show error banners to end users.
  if (QUIET_UI && tone === 'error') {
    if (SHOW_ERRORS_AS_TOAST) {
      // minimal, neutral line (optional)
      const b = document.getElementById('banner');
      if (b) b.innerHTML = `<span style="color:var(--muted)">${msg}</span>`;
    } else {
      // log to console only
      console.warn('[ui suppressed]', msg);
    }
    return;
  }
  const b = document.getElementById('banner');
  if (!b) { console[tone === 'error' ? 'error' : 'log'](msg); return; }
  const color = tone === 'error' ? 'var(--danger)' : (tone === 'ok' ? 'var(--ok)' : 'var(--muted)');
  b.innerHTML = `<span style="color:${color}">${msg}</span>`;
}

// === Dynamic targets (build from actual capabilities) ===

// order + labels reused to build <optgroup>s
const GROUPS_ORDER = ['text', 'documents', 'archives', 'spreadsheets', 'images', 'media'];
const GROUP_LABELS = { text: 'Text', documents: 'Documents', spreadsheets: 'Spreadsheets', images: 'Images', media: 'Media' };

/** Map input kind -> allowed output set, based on your converters and loaded vendors */
function targetsForKind(kind) {
  const out = new Set();

  if (kind === 'image') {
    if (ENABLE_OUTPUTS.images) ['png', 'jpeg', 'webp', 'svg'].forEach(x => out.add(x));
    if (ENABLE_OUTPUTS.documents && features.makePdf) out.add('pdf'); // needs jsPDF :contentReference[oaicite:0]{index=0}
  }
  else if (kind === 'pdf') {
    if (ENABLE_OUTPUTS.images) ['png', 'jpeg', 'webp', 'svg'].forEach(x => out.add(x));                     // images from PDF :contentReference[oaicite:1]{index=1}
    ['txt', 'md', 'html', 'json', 'csv', 'jsonl', 'rtf'].forEach(x => out.add(x));                              // text-ish from PDF :contentReference[oaicite:2]{index=2}
    if (ENABLE_OUTPUTS.documents && features.makeDocx) out.add('docx');                                 // PDF → DOCX when docx lib present :contentReference[oaicite:3]{index=3}
  }
  else if (kind === 'docx') {
    if (ENABLE_OUTPUTS.images) ['png', 'jpeg', 'webp', 'svg'].forEach(x => out.add(x));                      // DOCX → images :contentReference[oaicite:4]{index=4}
    ['txt', 'md', 'html', 'json'].forEach(x => out.add(x));                                                  // DOCX → text-ish :contentReference[oaicite:5]{index=5}
    if (ENABLE_OUTPUTS.documents && features.makePdf) out.add('pdf');                                   // DOCX → PDF needs jsPDF :contentReference[oaicite:6]{index=6}
  }
  else if (kind === 'pptx') {
    if (ENABLE_OUTPUTS.images) ['png', 'jpeg', 'webp', 'svg'].forEach(x => out.add(x));                      // PPTX → per-slide images :contentReference[oaicite:7]{index=7}
    ['txt', 'md', 'html', 'json'].forEach(x => out.add(x));                                                  // PPTX → text-ish :contentReference[oaicite:8]{index=8}
    if (ENABLE_OUTPUTS.documents && features.makePdf) out.add('pdf');                                   // PPTX → PDF needs jsPDF :contentReference[oaicite:9]{index=9}
    if (ENABLE_OUTPUTS.documents && features.makeDocx) out.add('docx');                                 // PPTX → DOCX needs docx lib :contentReference[oaicite:10]{index=10}
  }
  else if (kind === 'xlsx') {
    ['csv', 'json', 'html', 'xlsx'].forEach(x => out.add(x));                                                // XLSX outputs :contentReference[oaicite:11]{index=11}
  }
  else if (kind === 'csv') {
    ['xlsx', 'json', 'html', 'txt', 'md', 'csv'].forEach(x => out.add(x));                                     // CSV outputs :contentReference[oaicite:12]{index=12}
  }
  else if (kind === 'text') {
    ['txt', 'md', 'html', 'csv', 'json', 'jsonl', 'rtf'].forEach(x => out.add(x));                              // text-ish set (see PDF/DOCX branches) :contentReference[oaicite:13]{index=13}
    if (ENABLE_OUTPUTS.images) ['png', 'jpeg', 'webp', 'svg'].forEach(x => out.add(x));                      // uses textToImageBlobs :contentReference[oaicite:14]{index=14}
    if (ENABLE_OUTPUTS.documents && features.makePdf) out.add('pdf');                                   // via textishToPdf :contentReference[oaicite:15]{index=15}
    if (ENABLE_OUTPUTS.documents && features.makeDocx) out.add('docx');                                 // via textishToDocx :contentReference[oaicite:16]{index=16}
  }
  else if (kind === 'audio') {
    if (features.ffmpeg && ENABLE_OUTPUTS.media) ['mp3', 'wav', 'ogg', 'm4a', 'mp4', 'webm'].forEach(x => out.add(x)); // media targets (audio set + webm) :contentReference[oaicite:17]{index=17}
  }
  else if (kind === 'video') {
    if (features.ffmpeg && ENABLE_OUTPUTS.media) ['mp4', 'webm', 'gif', 'mp3', 'wav', 'ogg', 'm4a'].forEach(x => out.add(x)); // video + extract audio :contentReference[oaicite:18]{index=18}
  }
  else if (kind === 'archive') {
    ['zip', '7z', 'tar', 'tar.gz', 'tar.bz2', 'tar.xz'].forEach(x => out.add(x));
  }

  return out;
}
// ---- ARCHIVE → ZIP (client-only) ----
async function convertArchiveFile(file, target) {
  const m = await import('./archive-client.js');

  // choose writer based on target
  let outBlob;
  switch (target) {
    case 'zip': outBlob = await m.convertArchiveToZip(file); break;
    case 'tar': outBlob = await m.convertArchiveToTar(file); break;
    case 'tar.gz': outBlob = await m.convertArchiveToTarGz(file); break;
    case 'tar.bz2': outBlob = await m.convertArchiveToTarBz2(file); break;
    case 'tar.xz': outBlob = await m.convertArchiveToTarXz(file); break;
    case '7z': outBlob = await m.convertArchiveTo7z(file); break;
    default:
      throw new Error(`Unsupported archive target: ${target}`);
  }

  // derive a sensible filename
  const strip = n => (n || 'archive').replace(
    /\.(zip|rar|7z|tar|tgz|tbz2|txz|tar\.gz|tar\.bz2|tar\.xz)$/i, ''
  );
  const ext = target; // target already matches the desired extension strings
  const name = `${strip(file?.name)}.${ext}`;

  return [{ blob: outBlob, name }];
}


/** Intersection across all selected files */
function possibleTargetsForFiles(files) {
  if (!files.length) return new Set();
  let acc = null;
  for (const f of files) {
    const kind = detectKind(f); // your existing detector :contentReference[oaicite:19]{index=19}
    const set = targetsForKind(kind);
    acc = acc ? new Set([...acc].filter(x => set.has(x))) : set;
  }
  return acc || new Set();
}

function rebuildTargetDropdown(allowedSet) {
  targetFormat.innerHTML = '';
  if (!allowedSet || allowedSet.size === 0) {
    targetFormat.disabled = true;
    qualityWrap.style.display = 'none';
    return;
  }
  targetFormat.disabled = false;

  for (const group of GROUPS_ORDER) {
    const items = (TARGET_GROUPS[group] || []).filter(([val]) => allowedSet.has(val));
    if (!items.length) continue;

    const og = document.createElement('optgroup');
    og.label = t('group_' + group);       // localized group label

    for (const [val] of items) {
      const o = document.createElement('option');
      o.value = val;
      o.textContent = optLabel(val);      // localized option label
      og.appendChild(o);
    }
    targetFormat.appendChild(og);
  }

  // keep previous selection if still valid, else pick the first
  const keep = allowedSet.has(targetFormat.value) ? targetFormat.value : (targetFormat.querySelector('option')?.value || '');
  if (keep) targetFormat.value = keep;

  qualityWrap.style.display = (targetFormat.value === 'jpeg' || targetFormat.value === 'webp') ? '' : 'none';
}

function refreshTargetDropdown() {
  if (!targetFormat || !qualityWrap) return;

  const allowed = possibleTargetsForFiles(state.files);

  // Rebuild options but disable those not allowed for current selection
  for (const o of targetFormat.querySelectorAll('option')) {
    o.disabled = allowed.size > 0 && !allowed.has(o.value);
  }

  // If nothing is allowed, tell the user (red, localized)
  if (state.files.length > 0 && allowed.size === 0) {
    const exts = state.files.map(f => '.' + (f.name.split('.').pop() || '?')).join(', ');
    showBanner(t('banner.noCommonFor', { exts }), 'error');
  }

  // quality toggle
  const v = targetFormat.value;
  qualityWrap.style.display = (v === 'jpeg' || v === 'webp') ? '' : 'none';
}


// Remove one file by index
function removeFileAt(index) {
  if (!Array.isArray(state.files)) return;
  if (index < 0 || index >= state.files.length) return;
  const f = state.files.splice(index, 1)[0];
  renderFileList();
  if (typeof refreshTargetDropdown === 'function') refreshTargetDropdown();
  if (typeof showBanner === 'function') {
    const name = f?.name || f?.file?.name || `file #${index + 1}`;
    showBanner(`Removed ${name}.`, 'ok');
  }
  if (state.files.length === 0) {
    try { downloads.hidden = true; downloadLinks.innerHTML = ''; } catch { }
  }
  if (fileInput) fileInput.value = ''; // ← add this line
}

// Find the list container (adjust selector if yours differs)
function getFileListEl() {
  return document.querySelector('#file-list, #files, [data-role="file-list"]');
}
/* ========= 5) Build target dropdown ========= */
/* ========= 5) Build target dropdown ========= */
function buildTargets() {
  if (!targetFormat || !qualityWrap) return;

  const groupsOrder = ['text', 'documents', 'spreadsheets', 'images', 'media'];
  const groupLabelKey = { text: 'group_text', documents: 'group_documents', spreadsheets: 'group_spreadsheets', images: 'group_images', media: 'group_media' };

  targetFormat.innerHTML = '';
  for (const key of groupsOrder) {
    if (!ENABLE_OUTPUTS[key]) continue;
    const items = TARGET_GROUPS[key]; if (!items) continue;

    const og = document.createElement('optgroup');
    og.label = t(groupLabelKey[key]);
    items.forEach(([val/*, labelIgnored*/]) => {
      const o = document.createElement('option');
      o.value = val;
      o.textContent = optLabel(val);            // ← localized label
      og.appendChild(o);
    });
    targetFormat.appendChild(og);
  }
  if (ENABLE_OUTPUTS.images && [...targetFormat.querySelectorAll('option')].some(o => o.value === 'jpeg')) {
    targetFormat.value = 'jpeg';
  }
  const v = targetFormat.value;
  qualityWrap.style.display = (v === 'jpeg' || v === 'webp') ? '' : 'none';
}
window.buildTargets = buildTargets;                // builds all groups/labels
window.refreshTargetDropdown = refreshTargetDropdown; // filters to only valid targets


if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    buildTargets();            // populate groups/labels
    refreshTargetDropdown();   // then filter for current files
  });
} else {
  buildTargets();
  refreshTargetDropdown();
}



refreshMemoryPill();

/* Create a single promise and await it before converting */
const vendorsReady = ensureVendors();

/* ========= 6) File I/O & UI events ========= */
dropzone.addEventListener('dragenter', e => { e.preventDefault(); dropzone.classList.add('drag'); });
dropzone.addEventListener('dragover', e => { e.preventDefault(); dropzone.classList.add('drag'); });
dropzone.addEventListener('dragleave', e => { e.preventDefault(); dropzone.classList.remove('drag'); });
dropzone.addEventListener('drop', e => { e.preventDefault(); dropzone.classList.remove('drag'); addFiles([...e.dataTransfer.files]); });
fileInput.addEventListener('change', () => {
  addFiles([...fileInput.files]);        // spread the FileList
});
$('#clear-btn').addEventListener('click', () => {
  state.files = []; state.outputs = [];
  renderFileList();
  if (typeof refreshTargetDropdown === 'function') refreshTargetDropdown();   // <-- add this
  downloadLinks.innerHTML = ''; downloads.hidden = true; fileInput.value = '';
  showBanner(t('banner.cleared'), 'ok');

});


limitMode.addEventListener('change', () => { const isManual = limitMode.value === 'manual'; state.useAuto = !isManual; manualLimit.disabled = !isManual; state.budget = isManual ? Math.max(10, +manualLimit.value) * 1048576 : estimateSafeBudgetBytes(); refreshMemoryPill(); });
manualLimit.addEventListener('input', () => { state.budget = Math.max(10, +manualLimit.value) * 1048576; refreshMemoryPill(); });

targetFormat.addEventListener('change', () => {
  const v = targetFormat.value;
  qualityWrap.style.display = (v === 'jpeg' || v === 'webp') ? '' : 'none';
});

$('#theme-btn')?.addEventListener('click', () => { const r = document.documentElement; r.dataset.theme = r.dataset.theme === 'light' ? '' : 'light'; });
$('#share-btn')?.addEventListener('click', async () => { try { if (navigator.share) { await navigator.share({ title: document.title, url: location.href }); } else { await navigator.clipboard.writeText(location.href); showBanner('Link copied to clipboard.', 'ok'); } } catch { } });

function addFiles(files) {
  if (!files?.length) return;

  const totalAdded = files.reduce((s, f) => s + f.size, 0);
  const current = state.files.reduce((s, f) => s + f.size, 0);
  if (current + totalAdded > state.budget) {
    showBanner(t('banner.tooMuchData', { total: fmtBytes(current + totalAdded), budget: fmtBytes(state.budget) }), 'error');
  }

  state.files.push(...files);
  renderFileList();
  if (typeof refreshTargetDropdown === 'function') refreshTargetDropdown();

  // What got added?
  const justExts = files.map(f => (f.name.match(/\.([^.]+)$/)?.[1] || '').toLowerCase());
  const unsupported = files.filter(f => detectKind(f) === 'unknown');


  const unsupportedNow = state.files.filter(f => detectKind(f) === 'unknown');
  if (unsupportedNow.length) {
    const ex = unsupportedNow.map(f => '.' + (f.name.split('.').pop() || '?')).join(', ');
    showBanner(t('banner.unsupportedPresent', { exts: ex }), 'error');
  }

  // If unsupported were in the batch, warn (red)
  if (unsupported.length) {
    const exts = unsupported.map(f => '.' + (f.name.split('.').pop() || '?')).join(', ');
    showBanner(t('banner.unsupportedAdded', { exts }), 'error');
    return;
  }

  // If the whole selection has no common conversion, warn (red)
  const allowed = possibleTargetsForFiles(state.files);
  if (state.files.length > 0 && allowed.size === 0) {
    const allExts = state.files.map(f => '.' + (f.name.split('.').pop() || '?')).join(', ');
    showBanner(t('banner.noCommonFor', { exts: allExts }), 'error');
    return;
  }

  // Otherwise: green “added”
  const n = files.length;
  showBanner(t('banner.added', { n, files: wordFiles(n, APP_LANG), total: state.files.length }), 'ok');
}

function applyUrlTarget() {
  try {
    const to = new URLSearchParams(location.search).get('to');
    if (!to || typeof targetFormat === 'undefined' || !targetFormat) return;

    const ok = [...targetFormat.options].some(o => o.value === to);
    if (ok) {
      targetFormat.value = to;

      // Toggle quality UI for formats that support it
      if (typeof qualityWrap !== 'undefined' && qualityWrap) {
        qualityWrap.style.display = (to === 'jpeg' || to === 'webp') ? '' : 'none';
      }
    }
  } catch { }
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    buildTargets();
    refreshTargetDropdown();
    applyUrlTarget();
  });
} else {
  buildTargets();
  refreshTargetDropdown();
  applyUrlTarget();
}


function detectKind(file) {
  const n = file.name.toLowerCase();
  const t = (file.type || '').toLowerCase();

  if (t.startsWith('image/') || /\.(png|jpe?g|webp|svg)$/.test(n)) return 'image';
  if (/\.docx$/.test(n) || t === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') return 'docx';
  if (/\.pptx$/.test(n) || t === 'application/vnd.openxmlformats-officedocument.presentationml.presentation') return 'pptx';
  if (/\.pdf$/.test(n) || t === 'application/pdf') return 'pdf';
  if (/\.xlsx$/.test(n) || t === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet') return 'xlsx';
  if (/\.csv$/.test(n) || t === 'text/csv') return 'csv';
  if (t.startsWith('text/') || ['application/json', 'text/html', 'text/markdown'].includes(t) || /\.(txt|md|json|html)$/.test(n)) return 'text';
  if (/\.(zip|rar|r\d{2}|rev|7z|tar|tgz|tar\.gz|tbz|tar\.bz2|txz|tar\.xz)$/.test(n)) return 'archive';

  // NEW: audio & video
  if (t.startsWith('audio/') || /\.(mp3|wav|ogg|m4a|aac|flac)$/.test(n)) return 'audio';
  if (t.startsWith('video/') || /\.(mp4|webm|ogg|ogv|mov|mkv|avi|m4v)$/.test(n)) return 'video';

  return 'unknown';
}

function renderFileList() {
  fileList.innerHTML = '';
  if (!state.files.length) {
    fileList.innerHTML = `<div class="hint" style="padding:12px 0">${t('noFilesYet') || 'No files yet.'}</div>`;
    return;
  }

  state.files.forEach((f, i) => {
    const card = el('div', 'filecard');

    // Left: filename + meta (NO innerHTML — prevent XSS)
    const meta = el('div', 'file-meta');

    const nameWrap = el('div', 'f-name');
    nameWrap.setAttribute('aria-disabled', 'true');
    nameWrap.title = f.name;

    const strong = document.createElement('strong');
    strong.textContent = f.name; // safe
    nameWrap.append(strong);

    const sub = el('div', 'sub');
    sub.textContent = `${fmtBytes(f.size)} • ${f.type || t('unknown')}`;
    meta.append(nameWrap, sub);

    // Right controls
    const ctrls = el('div', 'file-controls');

    const badge = el('div', 'badge');
    badge.textContent = detectKind(f);

    const prog = document.createElement('progress');
    prog.max = 100;
    prog.value = 0;
    prog.id = 'prog-' + i;
    // optional: ARIA for better a11y
    prog.setAttribute('aria-label', t('converting') || 'Converting…');

    const status = el('div', 'status');
    status.id = 'status-' + i;
    status.textContent = t(t('queued')); // localized
    status.setAttribute('aria-live', 'polite'); // announce changes

    const rm = document.createElement('button');
    rm.type = 'button';
    rm.className = 'file-remove';
    rm.dataset.index = i;
    rm.setAttribute('aria-label', `${t('remove') || 'Remove'} ${f.name}`);
    rm.title = t('remove') || 'Remove';
    rm.textContent = '×';

    ctrls.append(badge, prog, status, rm);
    card.append(meta, ctrls);
    fileList.append(card);
  });
}

function setStatus(iOrUid, key, vars) {
  const s = document.getElementById('status-' + iOrUid);
  if (s) s.textContent = t(key, vars);
}

// one-time: event delegation for the ✕ button
document.addEventListener('click', (e) => {
  const btn = e.target.closest('.file-remove');
  if (!btn) return;
  const idx = Number(btn.dataset.index);
  removeFileAt(idx);
});





/* ========= 7) Conversion dispatcher (mixed batch supported) ========= */
async function convertFile(file, target, index) {
  const kind = detectKind(file);
  if (kind === 'image') return convertImageFile(file, target);
  if (kind === 'pdf') return convertPdfFile(file, target);
  if (kind === 'docx') return convertDocxFile(file, target);
  if (kind === 'pptx') return convertPptxFile(file, target);
  if (kind === 'xlsx' || kind === 'csv') return convertSheetFile(file, target);
  if (kind === 'text') return convertTextFile(file, target);
  if (kind === 'audio' || kind === 'video') return convertMediaFile(file, target, kind, index);
  if (kind === 'archive') return convertArchiveFile(file, target);
  throw new Error('Unsupported file type');
}

function wireFFmpegProgress(ff, index) {
  const handler = ({ ratio, progress }) => {
    const p = Math.max(0, Math.min(100, Math.round(((ratio ?? progress) || 0) * 100)));
    const progEl = document.getElementById('prog-' + index);
    const statusEl = document.getElementById('status-' + index);
    if (progEl) progEl.value = p;
    if (statusEl) statusEl.textContent = p >= 100 ? t('finishing') : t('convertingPct', { pct: p });
  };
  if (typeof ff.setProgress === 'function') ff.setProgress(handler);
  else if (typeof ff.on === 'function') { try { ff.off?.('progress', ff._progressHandler); } catch { } ff._progressHandler = handler; ff.on('progress', handler); }
}



// Local-only: ensure the UMD wrapper is present (no CDN)
async function ensureFFmpegWrapperLocal() {
  if (window.FFmpeg?.createFFmpeg) return true;
  const BASE = '/vendor/ffmpeg/';
  await new Promise((resolve, reject) => {
    const s = document.createElement('script');
    s.src = BASE + 'ffmpeg.js';
    s.async = true;
    s.onload = resolve;
    s.onerror = () => reject(new Error('Failed to load local ' + s.src));
    document.head.appendChild(s);
  });
  return !!(window.FFmpeg && window.FFmpeg.createFFmpeg);
}


// Exec shim: accepts (...args) or an array; uses exec() if present, else run()
async function ffExec(ff, ...args) {
  // allow ffExec(ff, ['-i','in','out']) and ffExec(ff, '-i','in','out')
  const argv = (args.length === 1 && Array.isArray(args[0])) ? args[0] : args;
  if (typeof ff.exec === 'function') return ff.exec(argv);
  return ff.run(...argv);
}

/* ---- Text → many ---- */
// Media (audio/video) → audio/video/gif — MT when possible, ST otherwise

// Drop-in: replaces your entire convertMediaFile(...)
async function convertMediaFile(file, target, kind, index) {
  // Status: Preparing…
  try {
    const s = document.getElementById('status-' + index);
    if (s) s.textContent = 'Preparing…';
    const p = document.getElementById('prog-' + index);
    if (p && typeof p.value === 'number') p.value = 0;
  } catch { }

  const ff = await needFFmpeg();

  // Per-row progress (clamped & robust for both 0.12 'progress' and legacy 'ratio')
  const update = ({ ratio, progress } = {}) => {
    let val = Number.isFinite(progress) ? progress
      : Number.isFinite(ratio) ? ratio
        : 0;
    if (!Number.isFinite(val)) val = 0;
    if (val < 0) val = 0;
    if (val > 1) val = 1;

    const pct = Math.round(val * 100);
    const pr = document.getElementById('prog-' + index);
    const st = document.getElementById('status-' + index);
    if (pr) pr.value = pct;
    if (st) st.textContent = pct >= 100 ? t('finishing') : `Converting…`;
  };
  if (typeof ff.setProgress === 'function') ff.setProgress(update);
  else if (typeof ff.on === 'function') {
    try { ff.off?.('progress', ff._rowHandlers?.[index]); } catch { }
    (ff._rowHandlers ||= {});
    ff._rowHandlers[index] = update;
    ff.on('progress', update);
  }

  // Basic validation
  const audioTargets = new Set(['mp3', 'wav', 'ogg', 'm4a']);
  const videoTargets = new Set(['mp4', 'webm', 'gif']);
  const isAudioIn = kind === 'audio';
  const isVideoIn = kind === 'video';
  if (isAudioIn && !audioTargets.has(target)) throw new Error('Audio → ' + target.toUpperCase() + ' not supported');
  if (isVideoIn && !(videoTargets.has(target) || audioTargets.has(target))) throw new Error('Video → ' + target.toUpperCase() + ' not supported');
  if (target === 'gif' && !isVideoIn) throw new Error('GIF is only from video input');

  // --- IO helpers (fixed) ---
  // pick a safe fetchFile that returns ArrayBuffer/Uint8Array; DO NOT call it yet
  const fetchFileFn =
    window.FFmpeg?.fetchFile ||
    window.fetchFile ||
    ((blob) => blob.arrayBuffer());

  if (!file || typeof file.arrayBuffer !== 'function') {
    throw new Error('Input file is missing or not a Blob/File.');
  }

  const inExt = (file.name?.match(/\.([^.]+)$/)?.[1] || (isAudioIn ? 'audio' : 'video')).toLowerCase();
  const inName = `in.${inExt}`;
  const outName = `out.${target}`;

  // Write input (prefer new API; fallback to FS)
  const data = await fetchFileFn(file);            // ArrayBuffer or Uint8Array
  const inputU8 = data instanceof Uint8Array ? data : new Uint8Array(data);
  if (typeof ff.writeFile === 'function') {
    await ff.writeFile(inName, inputU8);
  } else {
    ff.FS('writeFile', inName, inputU8);
  }

  // Build args
  let args = ['-i', inName];
  if (audioTargets.has(target)) {
    args.push('-vn');
    if (target === 'mp3') args.push('-c:a', 'libmp3lame', '-b:a', '192k');
    if (target === 'wav') args.push('-c:a', 'pcm_s16le', '-ar', '44100');
    if (target === 'ogg') args.push('-c:a', 'libvorbis', '-q:a', '5');
    if (target === 'm4a') args.push('-c:a', 'aac', '-b:a', '192k');
    args.push(outName);
  } else {
    if (target === 'webm') {
      args.push('-c:v', 'libvpx-vp9', '-b:v', '0', '-crf', '32', '-row-mt', '1');
      args.push('-c:a', 'libopus', '-b:a', '128k');
    } else if (target === 'mp4') {
      args.push('-c:v', 'libx264', '-preset', 'fast', '-crf', '23', '-pix_fmt', 'yuv420p');
      args.push('-c:a', 'aac', '-b:a', '160k', '-movflags', '+faststart');
    } else if (target === 'gif') {
      args.push('-t', '10', '-vf', 'fps=12,scale=480:-1:flags=lanczos');
    }
    args.push(outName);
  }

  // Run (uses exec() on 0.12+, run() on older via your shim)
  await ffExec(ff, args);

  // Read output (prefer new API; fallback to FS)
  const outBytes = (typeof ff.readFile === 'function')
    ? await ff.readFile(outName)
    : ff.FS('readFile', outName);

  const mime =
    target === 'mp3' ? 'audio/mpeg' :
      target === 'wav' ? 'audio/wav' :
        target === 'ogg' ? 'audio/ogg' :
          target === 'm4a' ? 'audio/mp4' :
            target === 'webm' ? 'video/webm' :
              target === 'mp4' ? 'video/mp4' :
                target === 'gif' ? 'image/gif' : 'application/octet-stream';

  // Cleanup (best effort)
  try { typeof ff.unlink === 'function' ? await ff.unlink(inName) : ff.FS('unlink', inName); } catch { }
  try { typeof ff.unlink === 'function' ? await ff.unlink(outName) : ff.FS('unlink', outName); } catch { }

  const blob = new Blob([outBytes], { type: mime });
  return [{ blob, name: (file.name.replace(/\.[^.]+$/, '') || 'output') + '.' + target }];
}







// Load only the FFmpeg UMD wrapper so the badge can turn green early.
// Load only the wrapper so the badge flips green early (no WASM yet)
// Loads just the wrapper so the badge can turn green early (no WASM yet)







// Kick it off right away so the badge goes green soon after load






/* ---- PPTX → textish / images-per-slide ---- */
async function convertPptxFile(file, target) {
  if (!features.pptx) throw new Error('PPTX reading needs JSZip');
  const ab = await file.arrayBuffer(); const zip = await JSZip.loadAsync(ab);
  const slideFiles = Object.keys(zip.files).filter(n => /^ppt\/slides\/slide\d+\.xml$/.test(n)).sort((a, b) => Number(a.match(/slide(\d+)\.xml/)[1]) - Number(b.match(/slide(\d+)\.xml/)[1]));
  const slides = [];
  for (let i = 0; i < slideFiles.length; i++) {
    const xml = await zip.file(slideFiles[i]).async('string');
    const dom = new DOMParser().parseFromString(xml, 'application/xml');
    const text = Array.from(dom.getElementsByTagNameNS('*', 't')).map(n => n.textContent.trim()).filter(Boolean).join('\n');
    slides.push({ i: i + 1, text });
  }
  if (['png', 'jpeg', 'webp', 'svg'].includes(target)) {
    if (!ENABLE_OUTPUTS.images) throw new Error('Image outputs disabled.');
    const outs = [];
    for (const s of slides) {
      const [img] = await textToImageBlobs(`Slide ${s.i}\n\n${s.text}`, target, `${baseName(file.name)}_slide${s.i}`);
      outs.push(img);
    }
    if (outs.length === 1) return [outs[0]];
    if (!window.JSZip) return outs;
    const zipOut = new JSZip(); outs.forEach(o => zipOut.file(o.name, o.blob));
    const blob = await zipOut.generateAsync({ type: 'blob' });
    return [{ blob, name: `${baseName(file.name)}_${target}_slides.zip` }];
  }
  const joined = slides.map(s => `[Slide ${s.i}]\n${s.text}`).join('\n\n');
  if (target === 'txt') return [{ blob: new Blob([joined], { type: 'text/plain' }), name: swapExt(file.name, 'txt') }];
  if (target === 'md') return [{ blob: new Blob([joined], { type: 'text/markdown' }), name: swapExt(file.name, 'md') }];
  if (target === 'html') return [{ blob: new Blob([`<!doctype html><meta charset="utf-8"><pre>${escapeHtml(joined)}</pre>`], { type: 'text/html' }), name: swapExt(file.name, 'html') }];
  if (target === 'json') return [{ blob: new Blob([JSON.stringify({ slides }, null, 2)], { type: 'application/json' }), name: swapExt(file.name, 'json') }];
  if (target === 'pdf') { if (!ENABLE_OUTPUTS.documents) throw new Error('Document outputs disabled.'); if (!features.makePdf) throw new Error('PDF output needs jsPDF'); return textishToPdf(joined, file.name); }
  if (target === 'docx') { if (!ENABLE_OUTPUTS.documents) throw new Error('Document outputs disabled.'); if (!features.makeDocx) throw new Error('DOCX output needs docx.min.js'); return textishToDocx(joined, file.name); }
  throw new Error('PPTX → ' + target.toUpperCase() + ' not supported');
}

/* ---- PDF → images/text ---- */
// Drop-in replacement
async function convertPdfFile(file, target) {
  // Ensure PDF.js is loaded (local vendor first, then CDN fallback)
  // Robust loader: supports UMD (.js) or ESM (.mjs), local first then CDN
  async function ensurePdf() {
    if (window.pdfjsLib?.getDocument) return;

    const loadScript = (src) =>
      new Promise((res, rej) => {
        const s = document.createElement("script");
        s.src = src;
        s.async = true;
        s.onload = res;
        s.onerror = () => rej(new Error("Failed to load " + src));
        document.head.appendChild(s);
      });

    // Try local UMD → CDN UMD → local ESM → CDN ESM
    const tryOrder = [
      () => loadScript("/vendor/pdf.min.js"),
      () => loadScript("https://unpkg.com/pdfjs-dist@4/legacy/build/pdf.min.js"),
      async () => {
        const mod = await import("/vendor/pdf.min.mjs");
        window.pdfjsLib = mod; // expose to rest of app
      },
      async () => {
        const mod = await import("https://unpkg.com/pdfjs-dist@4/build/pdf.min.mjs");
        window.pdfjsLib = mod;
      },
    ];

    let loaded = false;
    for (const step of tryOrder) {
      try { await step(); loaded = true; break; } catch { }
    }
    if (!loaded || !window.pdfjsLib?.getDocument) {
      throw new Error("Unable to load PDF.js");
    }

    // Worker: prefer local .js, then local .mjs, then CDN UMD, then CDN ESM
    const workerCandidates = [
      "/vendor/pdf.worker.min.js",
      "/vendor/pdf.worker.min.mjs",
      "https://unpkg.com/pdfjs-dist@4/legacy/build/pdf.worker.min.js",
      "https://unpkg.com/pdfjs-dist@4/build/pdf.worker.min.mjs",
    ];

    // Pick the first that exists; fall back to first if HEAD fails (file://)
    let workerSrc = workerCandidates[0];
    for (const url of workerCandidates) {
      try {
        const ok = await fetch(url, { method: "HEAD", cache: "no-store" }).then(r => r.ok);
        if (ok) { workerSrc = url; break; }
      } catch { /* ignore; e.g., file:// */ }
    }

    if (window.pdfjsLib?.GlobalWorkerOptions) {
      window.pdfjsLib.GlobalWorkerOptions.workerSrc = workerSrc;
    }

    // Flip capability badge
    if (typeof features === "object") features.pdf = !!window.pdfjsLib;
    try { typeof ensureVendors === "function" && ensureVendors(); } catch { }
  }



  await ensurePdf();
  if (!window.pdfjsLib?.getDocument) throw new Error("PDF support needs PDF.js");

  const ab = await file.arrayBuffer();
  const pdf = await pdfjsLib.getDocument({ data: ab }).promise;
  const count = pdf.numPages;

  // Image outputs
  if (["png", "jpeg", "webp", "svg"].includes(target)) {
    if (!ENABLE_OUTPUTS.images) throw new Error("Image outputs disabled.");
    const pages = [];
    const mime =
      target === "png" ? "image/png" : target === "jpeg" ? "image/jpeg" : "image/webp";

    for (let p = 1; p <= count; p++) {
      const page = await pdf.getPage(p);
      const viewport = page.getViewport({ scale: 2 });
      const canvas = document.createElement("canvas");
      canvas.width = viewport.width;
      canvas.height = viewport.height;
      const ctx = canvas.getContext("2d");
      await page.render({ canvasContext: ctx, viewport }).promise;

      if (target === "svg") {
        const dataUrl = canvas.toDataURL("image/png");
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${canvas.width}" height="${canvas.height}"><image href="${dataUrl}" width="100%" height="100%"/></svg>`;
        pages.push({
          blob: new Blob([svg], { type: "image/svg+xml" }),
          name: `${baseName(file.name)}_p${p}.svg`,
        });
      } else {
        const q =
          target === "png" ? undefined : Number((typeof quality !== "undefined" && quality?.value) || 0.92);
        const blob = await new Promise((res) => canvas.toBlob(res, mime, q));
        pages.push({ blob, name: `${baseName(file.name)}_p${p}.${target}` });
      }
    }

    if (pages.length === 1) return [pages[0]];
    if (!window.JSZip) return pages;

    const zip = new JSZip();
    pages.forEach((p) => zip.file(p.name, p.blob));
    const zipBlob = await zip.generateAsync({ type: "blob" });
    return [{ blob: zipBlob, name: `${baseName(file.name)}_${target}_images.zip` }];
  }

  // Text-ish targets
  let all = "";
  for (let p = 1; p <= count; p++) {
    const page = await pdf.getPage(p);
    const tc = await page.getTextContent();
    all += (p > 1 ? "\n\n" : "") + tc.items.map((it) => it.str).join(" ");
  }

  if (target === "md")
    return [{ blob: new Blob([all], { type: "text/markdown" }), name: swapExt(file.name, "md") }];

  if (target === "html")
    return [
      {
        blob: new Blob(
          [`<!doctype html><meta charset="utf-8"><pre style="white-space:pre-wrap">${escapeHtml(all)}</pre>`],
          { type: "text/html" }
        ),
        name: swapExt(file.name, "html"),
      },
    ];

  if (target === "json")
    return [
      {
        blob: new Blob([JSON.stringify({ text: all }, null, 2)], { type: "application/json" }),
        name: swapExt(file.name, "json"),
      },
    ];

  if (target === "csv")
    return [
      {
        blob: new Blob(
          [all.split("\n").map((l) => '"' + l.replaceAll('"', '""') + '"').join("\n")],
          { type: "text/csv" }
        ),
        name: swapExt(file.name, "csv"),
      },
    ];

  if (target === "jsonl")
    return [
      {
        blob: new Blob(
          [all.split("\n").map((l) => (l ? JSON.stringify({ line: l }) : "{}")).join("\n")],
          { type: "application/jsonl" }
        ),
        name: swapExt(file.name, "jsonl"),
      },
    ];

  if (target === "rtf")
    return [
      {
        blob: new Blob([`{\\rtf1\\ansi\n${escapeHtml(all).replace(/\n/g, "\\par\n")}}`], {
          type: "application/rtf",
        }),
        name: swapExt(file.name, "rtf"),
      },
    ];

  if (target === "docx") {
    if (!ENABLE_OUTPUTS.documents) throw new Error("Document outputs disabled.");
    if (!features.makeDocx) throw new Error("DOCX output needs docx.min.js");
    return textishToDocx(all, file.name);
  }

  if (target === "pdf") return [{ blob: file, name: file.name }];

  return [{ blob: new Blob([all], { type: "text/plain" }), name: swapExt(file.name, "txt") }];
}


/* ---- CSV/XLSX ⇄ ---- */
async function convertSheetFile(file, target) {
  const isCSV = file.name.toLowerCase().endsWith('.csv');
  if (isCSV) {
    const text = await file.text();
    if (target === 'xlsx') { if (!ENABLE_OUTPUTS.spreadsheets) throw new Error('Spreadsheet outputs disabled.'); if (!features.xlsx) throw new Error('CSV→XLSX needs SheetJS'); const wb = XLSX.read(text, { type: 'string' }); const out = XLSX.write(wb, { bookType: 'xlsx', type: 'array' }); return [{ blob: new Blob([out], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' }), name: swapExt(file.name, 'xlsx') }]; }
    if (target === 'json') { const wb = XLSX.read(text, { type: 'string' }); const ws = wb.Sheets[wb.SheetNames[0]]; const json = XLSX.utils.sheet_to_json(ws, { defval: null }); return [{ blob: new Blob([JSON.stringify(json, null, 2)], { type: 'application/json' }), name: swapExt(file.name, 'json') }]; }
    if (target === 'html') { const wb = XLSX.read(text, { type: 'string' }); const ws = wb.Sheets[wb.SheetNames[0]]; const html = XLSX.utils.sheet_to_html(ws); return [{ blob: new Blob([html], { type: 'text/html' }), name: swapExt(file.name, 'html') }]; }
    if (['txt', 'md', 'csv'].includes(target)) { if (target === 'csv') return [{ blob: new Blob([text], { type: 'text/csv' }), name: swapExt(file.name, 'csv') }]; if (target === 'txt') return [{ blob: new Blob([text], { type: 'text/plain' }), name: swapExt(file.name, 'txt') }]; if (target === 'md') return [{ blob: new Blob([text], { type: 'text/markdown' }), name: swapExt(file.name, 'md') }]; }
    throw new Error('CSV → ' + target.toUpperCase() + ' not supported');
  }
  // XLSX
  if (!features.xlsx) throw new Error('XLSX support needs SheetJS');
  if (!['csv', 'json', 'html', 'xlsx'].includes(target)) throw new Error('XLSX → ' + target.toUpperCase() + ' not supported');
  const ab = await file.arrayBuffer(); const wb = XLSX.read(ab, { type: 'array' }); const ws = wb.Sheets[wb.SheetNames[0]];
  if (target === 'csv') { const csv = XLSX.utils.sheet_to_csv(ws); return [{ blob: new Blob([csv], { type: 'text/csv' }), name: swapExt(file.name, 'csv') }]; }
  if (target === 'json') { const json = XLSX.utils.sheet_to_json(ws, { defval: null }); return [{ blob: new Blob([JSON.stringify(json, null, 2)], { type: 'application/json' }), name: swapExt(file.name, 'json') }]; }
  if (target === 'html') { const html = XLSX.utils.sheet_to_html(ws); return [{ blob: new Blob([html], { type: 'text/html' }), name: swapExt(file.name, 'html') }]; }
  if (target === 'xlsx') { const out = XLSX.write(wb, { bookType: 'xlsx', type: 'array' }); return [{ blob: new Blob([out], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' }), name: swapExt(file.name, 'xlsx') }]; }
}

/* ---- Images ⇄ Images / SVG / PDF ---- */
async function convertImageFile(file, target) {
  if (!['png', 'jpeg', 'webp', 'svg', 'pdf'].includes(target)) {
    throw new Error('Image → ' + target.toUpperCase() + ' supports PNG/JPEG/WebP/SVG/PDF');
  }
  if (target === 'pdf') {
    if (!ENABLE_OUTPUTS.documents) throw new Error('Document outputs disabled.');
    if (!features.makePdf) throw new Error('PDF output needs jsPDF');
    const bitmap = await createImageBitmap(file);
    const c = document.createElement('canvas'); c.width = bitmap.width; c.height = bitmap.height; c.getContext('2d').drawImage(bitmap, 0, 0);
    return imageToPdf(c, file.name);
  }
  if (!ENABLE_OUTPUTS.images) throw new Error('Image outputs disabled.');
  const bitmap = await createImageBitmap(file);
  const canvas = document.createElement('canvas'); canvas.width = bitmap.width; canvas.height = bitmap.height;
  const ctx = canvas.getContext('2d'); ctx.drawImage(bitmap, 0, 0);
  if (target === 'svg') {
    const dataUrl = canvas.toDataURL('image/png');
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${canvas.width}" height="${canvas.height}"><image href="${dataUrl}" width="100%" height="100%"/></svg>`;
    return [{ blob: new Blob([svg], { type: 'image/svg+xml' }), name: swapExt(file.name, 'svg') }];
  }
  const q = Number(quality.value || 0.92); const mime = target === 'png' ? 'image/png' : (target === 'jpeg' ? 'image/jpeg' : 'image/webp');
  const blob = await new Promise(res => canvas.toBlob(res, mime, target === 'png' ? undefined : q));
  return [{ blob, name: swapExt(file.name, target) }];
}

/* ---- Render text to image (used by DOCX/TXT/PPTX → JPEG/PNG/WebP/SVG) ---- */
function wrapText(ctx, text, maxWidth) {
  const words = text.split(/\s+/); const lines = []; let line = '';
  for (const w of words) {
    const test = line ? line + ' ' + w : w;
    if (ctx.measureText(test).width > maxWidth) { if (line) lines.push(line); line = w; } else { line = test; }
  }
  if (line) lines.push(line);
  return lines;
}
function drawTextToCanvas(text, { width = 1200, padding = 40, lineHeight = 28, font = '16px Arial' } = {}) {
  const c = document.createElement('canvas'); const ctx = c.getContext('2d');
  ctx.font = font;
  const maxWidth = width - padding * 2;
  const paragraphs = text.split(/\n{2,}/);
  let lines = [];
  paragraphs.forEach(p => {
    const pLines = wrapText(ctx, p.replace(/\n/g, ' '), maxWidth);
    lines.push(...pLines, ''); // blank line
  });
  if (lines[lines.length - 1] === '') lines.pop();
  const height = padding * 2 + Math.max(lineHeight * lines.length, lineHeight * 2);
  c.width = width; c.height = height;
  // bg + text
  ctx.fillStyle = '#ffffff'; ctx.fillRect(0, 0, width, height);
  ctx.fillStyle = '#111'; ctx.font = font;
  let y = padding + lineHeight;
  for (const ln of lines) { ctx.fillText(ln, padding, y); y += lineHeight; }
  return c;
}
async function textToImageBlobs(text, target, base) {
  if (target === 'svg') {
    const c = drawTextToCanvas(text, {});
    const dataUrl = c.toDataURL('image/png');
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${c.width}" height="${c.height}"><image href="${dataUrl}" width="100%" height="100%"/></svg>`;
    return [{ blob: new Blob([svg], { type: 'image/svg+xml' }), name: `${base}.svg` }];
  }
  const c = drawTextToCanvas(text, {});
  const mime = target === 'png' ? 'image/png' : (target === 'jpeg' ? 'image/jpeg' : 'image/webp');
  const q = target === 'png' ? undefined : Number(quality.value || 0.92);
  const blob = await new Promise(res => c.toBlob(res, mime, q));
  return [{ blob, name: `${base}.${target}` }];
}
// --- helpers to derive display name / badge from outputs ---
function extFromName(n) {
  const m = String(n).toLowerCase().match(/\.([a-z0-9]+)(?:\?.*)?$/);
  return m ? m[1] : '';
}
function displayNameForOutputs(origFile, outs, target) {
  // If we produced exactly one file (incl. a .zip), show its exact name.
  if (outs.length === 1) return outs[0].name;
  // Otherwise show the conceptual name (base + target ext) — status already shows "(N files)"
  return (origFile && target) ? (origFile.name.replace(/\.[^.]+$/, '') + '.' + target) : (outs[0]?.name || origFile?.name);
}
function badgeForOutputs(outs, target) {
  if (outs.length === 1) return extFromName(outs[0].name) || (target || '').toLowerCase();
  return (target || 'multi').toLowerCase();
}

/* ---- Textish → PDF/DOCX ---- */
async function textishToPdf(text, filename) {
  const { jsPDF } = window.jspdf || {};
  if (!jsPDF) throw new Error('jsPDF missing');
  const doc = new jsPDF({ unit: 'pt', format: 'a4' });
  const margin = 40, lh = 16, pageW = 595 - 2 * margin, pageH = 842 - 2 * margin;
  const lines = doc.splitTextToSize(text, pageW);
  let y = margin;
  for (const line of lines) { if (y > pageH) { doc.addPage(); y = margin; } doc.text(line, margin, y); y += lh; }
  const blob = doc.output('blob');
  return [{ blob, name: swapExt(filename, 'pdf') }];
}
async function imageToPdf(canvas, filename) {
  const { jsPDF } = window.jspdf || {};
  if (!jsPDF) throw new Error('jsPDF missing');
  const doc = new jsPDF({ unit: 'pt', format: 'a4' });
  const maxW = 500, maxH = 760;
  const r = Math.min(maxW / canvas.width, maxH / canvas.height, 1);
  const w = canvas.width * r, h = canvas.height * r;
  const dataUrl = canvas.toDataURL('image/jpeg', 0.92);
  doc.addImage(dataUrl, 'JPEG', (595 - w) / 2, (842 - h) / 2, w, h);
  const blob = doc.output('blob');
  return [{ blob, name: swapExt(filename, 'pdf') }];
}
async function textishToDocx(text, filename) {
  if (!window.docx) throw new Error('docx lib missing');
  const { Document, Packer, Paragraph } = window.docx;
  const paras = text.split(/\r?\n/).map(t => new Paragraph(t));
  const doc = new Document({ sections: [{ properties: {}, children: paras }] });
  const blob = await Packer.toBlob(doc);
  return [{ blob, name: swapExt(filename, 'docx') }];
}

/* ---- Simple HTML→MD & strip ---- */
function stripHtml(html) { const d = document.createElement('div'); d.innerHTML = html; return d.textContent || d.innerText || ''; }
function htmlToMarkdown(html) {
  const d = document.createElement('div'); d.innerHTML = html;
  d.querySelectorAll('h1,h2,h3,h4,h5,h6').forEach(h => { const lvl = +h.tagName[1]; h.outerHTML = '\n' + ('#'.repeat(lvl)) + ' ' + h.textContent + '\n'; });
  d.querySelectorAll('strong,b').forEach(n => { n.outerHTML = '**' + n.textContent + '**'; });
  d.querySelectorAll('em,i').forEach(n => { n.outerHTML = '*' + n.textContent + '*'; });
  d.querySelectorAll('a').forEach(a => { const href = a.getAttribute('href') || ''; a.outerHTML = '[' + a.textContent + '](' + href + ')'; });
  d.querySelectorAll('br').forEach(br => { br.outerHTML = '\n'; });
  d.querySelectorAll('p').forEach(p => { p.outerHTML = '\n' + p.textContent + '\n'; });
  d.querySelectorAll('ul').forEach(ul => { const lines = [...ul.querySelectorAll('li')].map(li => ' - ' + li.textContent).join('\n'); ul.outerHTML = '\n' + lines + '\n'; });
  d.querySelectorAll('ol').forEach((ol) => { const lines = [...ol.querySelectorAll('li')].map((li, i) => ` ${i + 1}. ${li.textContent}`).join('\n'); ol.outerHTML = '\n' + lines + '\n'; });
  return stripHtml(d.innerHTML).replace(/\n{3,}/g, '\n\n');
}

/* ========= 8) Orchestration ========= */
convertBtn.addEventListener('click', async () => {
  await vendorsReady;

  // Localized: "Add some files first."
  if (!state.files.length) { showBanner(t('banner.addFirst'), 'error'); return; }

  // 🔁 CANCEL previous run + RESET counters/UI
  state.runId += 1;
  const runId = state.runId;

  state.outputs = [];
  state.outputsByFile = {};
  downloadLinks.innerHTML = '';
  downloads.hidden = true;

  // Reset each row to t('queued') with 0% and non-clickable name
  renderFileList();

  // Setup this run
  const total = state.files.reduce((s, f) => s + f.size, 0);
  if (total > state.budget) {
    // Localized budget warning
    showBanner(
      t('banner.exceedsBudget', { total: fmtBytes(total), budget: fmtBytes(state.budget) }),
      'error'
    );
  }
  const concurrency = clamp(+($('#concurrency').value || 1), 1, 4);
  const target = targetFormat.value;

  let i = 0, active = 0, failed = 0;

  const next = () => {
    if (isStale(runId)) return; // stop scheduling if a new run started

    while (active < concurrency && i < state.files.length) {
      const jobIndex = i++;
      const f = state.files[jobIndex];
      active++;
      runJob(f, jobIndex, target, runId)
        .then(() => { if (isStale(runId)) return; active--; next(); })
        .catch(() => { if (isStale(runId)) return; active--; failed++; next(); });
    }

    if (!active && i >= state.files.length) {
      if (isStale(runId)) return; // old run finishing after a new run started

      // show/hide downloads section
      downloads.hidden = state.outputs.length === 0;
      // show/hide downloads section is already above

      // Count successes by file (robust even if a file emits multiple outputs)
      const total = state.files.length;
      const s = Object.values(state.outputsByFile).reduce((n, arr) => n + ((arr && arr.length) ? 1 : 0), 0);
      const f = failed; // your counter from run loop

      const L = window.APP_LANG || 'en';
      if (f === 0) {
        tb('banner.doneOk', { s, files: wordFiles(s, L) });       // ✅ green
      } else if (s > 0) {
        tb('banner.finishedMixed', { s, files: wordFiles(s, L), f });    // ❌ red
      } else {
        tb('banner.finishedFail', { f, files: wordFiles(f, L) });       // ❌ red
      }

      let msg, tone;
      if (f === 0) {
        // ✅ Only here we say "Done"
        msg = t('banner.doneOk', { s, files: wordFiles(s, L) });
        tone = 'ok';
      } else if (s > 0) {
        msg = t('banner.finishedMixed', { s, files: wordFiles(s, L), f });
        tone = 'error';
      } else {
        msg = t('banner.finishedFail', { f, files: wordFiles(f, L) });
        tone = 'error';
      }
      showBanner(msg, tone);

    }
  };

  next();
});



async function runJob(file, index, target, runId) {
  const card = document.getElementById('file-list')?.children[index];
  const status = $('#status-' + index);
  const prog = $('#prog-' + index);

  // Start: shrink bar + prevent download
  if (card) card.classList.add('is-converting');
  const nameEl = card?.querySelector('.f-name');
  if (nameEl) {
    nameEl.classList.remove('clickable');
    nameEl.setAttribute('aria-disabled', 'true');
    nameEl.removeAttribute('tabindex');
    nameEl.removeAttribute('role');
  }
  if (status) status.textContent = t('converting');
  if (prog) prog.value = 0;

  try {
    if (status) status.textContent = t('converting');
    if (prog) prog.value = 0;

    // let the progress handler know which row to update
    state.activeProgressIndex = index;
    const outs = await convertFile(file, target, index);
    if (isStale(runId)) return; // a newer run started; ignore late result

    // store per-file outputs & make filename clickable (for this run)
    registerOutputs(index, outs, runId, target);


    // add to global downloads list (only if still current)
    outs.forEach(({ blob, name }) => {
      if (isStale(runId)) return;
      const url = URL.createObjectURL(blob);
      const a = el('a');
      a.href = url; a.download = name; a.textContent = 'Download ' + name;
      downloadLinks.append(a);
      state.outputs.push({ name, blob, url });
    });

  }
  catch (err) {
    friendlyCatch(err, { status, card, runId });
  }
}


saveAllBtn.addEventListener('click', async () => {
  if (!state.outputs.length) {
    showBanner('No outputs yet. Convert first.', 'error');
    return;
  }

  // If the File System Access API exists, try it first.
  if ('showDirectoryPicker' in window) {
    try {
      const dir = await window.showDirectoryPicker({ mode: 'readwrite' });
      for (const out of state.outputs) {
        const fh = await dir.getFileHandle(out.name, { create: true });
        const ws = await fh.createWritable();
        await ws.write(out.blob);
        await ws.close();
      }
      showBanner('Saved all files to your chosen folder.', 'ok');
      return;
    } catch (e) {
      // User cancellation should NOT trigger any downloads.
      const name = e?.name || '';
      if (name === 'AbortError' || name === 'NotAllowedError') {
        // Cancel / permission denied by user → do nothing.
        showBanner('Save cancelled.', 'info');
        return;
      }
      // Other errors: surface and stop (don’t auto-download).
      console.warn('Save-all failed', e);
      showBanner('Couldn’t open the folder. Try again or download individually below.', 'error');
      return;
    }
  }

  // Fallback only if the picker is not supported at all:
  for (const a of [...downloadLinks.querySelectorAll('a')]) {
    a.click();
    await new Promise(r => setTimeout(r, 150));
  }
  showBanner('Triggered downloads for each file.', 'ok');
});


/* ========= 9) Inline ad reveal (optional) ========= */
(function () {
  if (!SHOW_ADS) { const fa = $('.footer-ads'); const ia = $('#inline-ad'); if (fa) fa.style.display = 'none'; if (ia) ia.style.display = 'none'; return; }
  const dl = $('#download-links'); const inlineAd = $('#inline-ad');
  const obs = new MutationObserver(() => { if (dl.children.length > 0) { if (inlineAd) inlineAd.style.display = 'block'; obs.disconnect(); } });
  if (dl) obs.observe(dl, { childList: true });
})();

showBanner(t('banner.readyHint'));

/* ========= 9) Ads toggles (unchanged) ========= */
(function () {
  const masterEnabled = (typeof window.SHOW_ADS !== 'undefined') ? !!window.SHOW_ADS : true;
  const sideEnabled = (() => {
    const anySet = (typeof window.SHOW_SIDE_ADS !== 'undefined')
      || (typeof window.show_side !== 'undefined')
      || (typeof window.showSide !== 'undefined');
    if (!anySet) return true;
    return !!(window.SHOW_SIDE_ADS ?? window.show_side ?? window.showSide);
  })();
  const bottomEnabled = (() => {
    const anySet = (typeof window.SHOW_BOTTOM_ADS !== 'undefined')
      || (typeof window.show_bottom !== 'undefined')
      || (typeof window.showBottom !== 'undefined');
    if (!anySet) return true;
    return !!(window.SHOW_BOTTOM_ADS ?? window.show_bottom ?? window.showBottom);
  })();

  const sideAds = document.getElementById('side-ads');
  const footerAds = document.querySelector('.footer-ads');
  const bottomAds = document.getElementById('bottom-ads');
  const inlineAd = document.getElementById('inline-ad');
  const downloadWrap = document.getElementById('download-links');

  const setBottomSafe = (px) => { document.documentElement.style.setProperty('--bottom-safe', '0px'); };
  const measureAdHeight = () => {
    const cand = [];
    const fa = document.querySelector('.footer-ads');
    const ba = document.getElementById('bottom-ads');
    if (fa && fa.offsetParent !== null) cand.push(fa);
    if (ba && ba.offsetParent !== null) cand.push(ba);
    [fa, ba].forEach(el => { if (el && !cand.includes(el) && isShown(el)) cand.push(el); });
    if (!cand.length) return 0;
    const h = Math.max(...cand.map(el => el.getBoundingClientRect().height || 0));
    return h;
  };
  const isShown = (el) => {
    const style = window.getComputedStyle(el);
    return style && style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0';
  };

  if (!masterEnabled) {
    [sideAds, footerAds, bottomAds, inlineAd].forEach(n => n && n.remove());
    setBottomSafe(0);
    return;
  }
  if (!sideEnabled && sideAds) sideAds.remove();
  if (!bottomEnabled) {
    if (footerAds) footerAds.remove();
    if (bottomAds) bottomAds.remove();
    setBottomSafe(0);
  }

  const railMedia = window.matchMedia('(min-width: 1200px)');
  const updatePlacement = () => {
    const wide = railMedia.matches;
    const liveSide = document.getElementById('side-ads');
    if (liveSide) liveSide.style.display = (sideEnabled && wide) ? 'block' : 'none';
    const liveFooter = document.querySelector('.footer-ads');
    if (liveFooter) liveFooter.style.display = (bottomEnabled && !wide) ? '' : 'none';
    const liveBottom = document.getElementById('bottom-ads');
    if (liveBottom) liveBottom.style.display = (bottomEnabled && wide) ? 'flex' : 'none';
    setBottomSafe(measureAdHeight());
  };
  railMedia.addEventListener('change', updatePlacement);
  updatePlacement();

  (() => {
    const root = document.getElementById('bottom-ads');
    if (!root) return;
    const btn = root.querySelector('.ad-close');
    if (!btn) return;
    btn.addEventListener('click', () => {
      root.remove();
      setBottomSafe(measureAdHeight());
    });
  })();

  if (inlineAd && downloadWrap) {
    const obs = new MutationObserver(() => {
      if (downloadWrap.children.length > 0) {
        inlineAd.style.display = 'block';
        obs.disconnect();
      }
    });
    obs.observe(downloadWrap, { childList: true });
  }

  let ro;
  const watch = () => {
    setBottomSafe(measureAdHeight());
    if ('ResizeObserver' in window) {
      ro = new ResizeObserver(() => setBottomSafe(measureAdHeight()));
      const fa = document.querySelector('.footer-ads');
      const ba = document.getElementById('bottom-ads');
      if (fa) ro.observe(fa);
      if (ba) ro.observe(ba);
    } else {
      window.addEventListener('resize', () => setBottomSafe(measureAdHeight()));
    }
  };
  window.requestAnimationFrame(watch);
})();

/* I18N AUTO PATCH */
// Ensure English pack has the new keys; other languages will fall back to these.
try {
  // === Banner i18n (adds only the keys we need) ===
  Object.assign(I18N.en, {
    'banner.added': 'Added {n} {files}.',
    'banner.doneOk': 'Done. {s} {files} converted.',
    'banner.finishedFail': 'Failed {f} {files}.',
    'banner.finishedMixed': 'Completed with errors: {s} {files} converted, {f} failed.',
    'banner.noCommonFor': 'No common conversion for: {exts}.',
    'banner.removedX': 'Removed {name}.',
    'banner.unsupportedAdded': 'Ignored unsupported files: {names}.',
    'banner.unsupportedPresent': 'Unsupported file types present: {exts}.'
  });

  // Arabic
  I18N.ar && Object.assign(I18N.ar, {
    'banner.added': 'تمت إضافة {n} {files}.',
    'banner.doneOk': 'تمّ. تمّ تحويل {s} {files}.',
    'banner.finishedFail': 'فشل {f} {files}.',
    'banner.finishedMixed': 'اكتمل مع أخطاء: تمّ تحويل {s} {files}، فشل {f}.',
    'banner.noCommonFor': 'لا يوجد تحويل مشترك لهذه الامتدادات: {exts}.',
    'banner.removedX': 'تمت إزالة {name}.',
    'banner.unsupportedAdded': 'تم تجاهل الملفات غير المدعومة: {names}.',
    'banner.unsupportedPresent': 'أنواع ملفات غير مدعومة موجودة: {exts}.'
  });

  // German
  I18N.de && Object.assign(I18N.de, {
    'banner.added': 'Hinzugefügt {n} {files}.',
    'banner.doneOk': 'Fertig. {s} {files} konvertiert.',
    'banner.finishedFail': '{f} {files} fehlgeschlagen.',
    'banner.finishedMixed': 'Abgeschlossen mit Fehlern: {s} {files} konvertiert, {f} fehlgeschlagen.',
    'banner.noCommonFor': 'Keine gemeinsame Konvertierung für: {exts}.',
    'banner.removedX': '{name} entfernt.',
    'banner.unsupportedAdded': 'Nicht unterstützte Dateien ignoriert: {names}.',
    'banner.unsupportedPresent': 'Nicht unterstützte Dateitypen vorhanden: {exts}.'
  });

  // Spanish
  I18N.es && Object.assign(I18N.es, {
    'banner.added': 'Añadidos {n} {files}.',
    'banner.doneOk': 'Listo. {s} {files} convertidos.',
    'banner.finishedFail': 'Fallaron {f} {files}.',
    'banner.finishedMixed': 'Completado con errores: {s} {files} convertidos, {f} fallaron.',
    'banner.noCommonFor': 'Sin conversión común para: {exts}.',
    'banner.removedX': 'Se eliminó {name}.',
    'banner.unsupportedAdded': 'Se ignoraron archivos no compatibles: {names}.',
    'banner.unsupportedPresent': 'Hay tipos de archivo no compatibles: {exts}.'
  });

  // French
  I18N.fr && Object.assign(I18N.fr, {
    'banner.added': 'Ajout de {n} {files}.',
    'banner.doneOk': 'Terminé. {s} {files} convertis.',
    'banner.finishedFail': 'Échec pour {f} {files}.',
    'banner.finishedMixed': 'Terminé avec des erreurs : {s} {files} convertis, {f} échecs.',
    'banner.noCommonFor': 'Aucune conversion commune pour : {exts}.',
    'banner.removedX': '{name} supprimé.',
    'banner.unsupportedAdded': 'Fichiers non pris en charge ignorés : {names}.',
    'banner.unsupportedPresent': 'Types de fichiers non pris en charge présents : {exts}.'
  });

  // Hindi
  I18N.hi && Object.assign(I18N.hi, {
    'banner.added': '{n} {files} जोड़े गए।',
    'banner.doneOk': 'सम्पन्न। {s} {files} परिवर्तित।',
    'banner.finishedFail': '{f} {files} विफल।',
    'banner.finishedMixed': 'त्रुटियों के साथ पूरा: {s} {files} परिवर्तित, {f} विफल।',
    'banner.noCommonFor': 'इन फ़ाइलों के लिए कोई सामान्य रूपांतरण संभव नहीं: {exts}।',
    'banner.removedX': '{name} हटाया गया।',
    'banner.unsupportedAdded': 'असमर्थित फ़ाइलें अनदेखी: {names}।',
    'banner.unsupportedPresent': 'असमर्थित फ़ाइल प्रकार मौजूद: {exts}।'
  });

  // Italian
  I18N.it && Object.assign(I18N.it, {
    'banner.added': 'Aggiunti {n} {files}.',
    'banner.doneOk': 'Fatto. {s} {files} convertiti.',
    'banner.finishedFail': 'Non riusciti {f} {files}.',
    'banner.finishedMixed': 'Completato con errori: {s} {files} convertiti, {f} non riusciti.',
    'banner.noCommonFor': 'Nessuna conversione comune per: {exts}.',
    'banner.removedX': '{name} rimosso.',
    'banner.unsupportedAdded': 'File non supportati ignorati: {names}.',
    'banner.unsupportedPresent': 'Sono presenti tipi di file non supportati: {exts}.'
  });

  // Japanese
  I18N.ja && Object.assign(I18N.ja, {
    'banner.added': '{n} {files}を追加しました。',
    'banner.doneOk': '完了。{s} {files}を変換しました。',
    'banner.finishedFail': '{f} {files}の変換に失敗しました。',
    'banner.finishedMixed': 'エラーありで完了：{s} {files}を変換、{f} 件失敗。',
    'banner.noCommonFor': '共通の変換先がありません: {exts}。',
    'banner.removedX': '{name} を削除しました。',
    'banner.unsupportedAdded': '未対応のファイルを無視しました: {names}。',
    'banner.unsupportedPresent': '未対応のファイル形式が含まれています: {exts}。'
  });

  // Korean
  I18N.ko && Object.assign(I18N.ko, {
    'banner.added': '{n} {files} 추가됨.',
    'banner.doneOk': '완료. {s} {files} 변환됨.',
    'banner.finishedFail': '{f} {files} 실패.',
    'banner.finishedMixed': '오류와 함께 완료: {s} {files} 변환, {f} 실패.',
    'banner.noCommonFor': '공통 변환 대상이 없습니다: {exts}.',
    'banner.removedX': '{name} 제거됨.',
    'banner.unsupportedAdded': '지원되지 않는 파일을 무시했습니다: {names}.',
    'banner.unsupportedPresent': '지원되지 않는 파일 형식이 포함되어 있습니다: {exts}.'
  });

  // Dutch
  I18N.nl && Object.assign(I18N.nl, {
    'banner.added': '{n} {files} toegevoegd.',
    'banner.doneOk': 'Klaar. {s} {files} geconverteerd.',
    'banner.finishedFail': '{f} {files} mislukt.',
    'banner.finishedMixed': 'Voltooid met fouten: {s} {files} geconverteerd, {f} mislukt.',
    'banner.noCommonFor': 'Geen gemeenschappelijke conversie mogelijk voor: {exts}.',
    'banner.removedX': '{name} verwijderd.',
    'banner.unsupportedAdded': 'Niet-ondersteunde bestanden genegeerd: {names}.',
    'banner.unsupportedPresent': 'Niet-ondersteunde bestandstypen aanwezig: {exts}.'
  });

  // Polish
  I18N.pl && Object.assign(I18N.pl, {
    'banner.added': 'Dodano {n} {files}.',
    'banner.doneOk': 'Gotowe. {s} {files} skonwertowane.',
    'banner.finishedFail': 'Niepowiodło się {f} {files}.',
    'banner.finishedMixed': 'Zakończono z błędami: skonwertowano {s} {files}, {f} niepowiodło się.',
    'banner.noCommonFor': 'Brak wspólnej konwersji dla: {exts}.',
    'banner.removedX': 'Usunięto {name}.',
    'banner.unsupportedAdded': 'Pominięto nieobsługiwane pliki: {names}.',
    'banner.unsupportedPresent': 'Występują nieobsługiwane typy plików: {exts}.'
  });

  // Portuguese (Portugal)
  I18N.pt && Object.assign(I18N.pt, {
    'banner.added': 'Adicionados {n} {files}.',
    'banner.doneOk': 'Concluído. {s} {files} convertidos.',
    'banner.finishedFail': 'Falharam {f} {files}.',
    'banner.finishedMixed': 'Concluído com erros: {s} {files} convertidos, {f} falharam.',
    'banner.noCommonFor': 'Sem conversão comum para: {exts}.',
    'banner.removedX': '{name} removido.',
    'banner.unsupportedAdded': 'Ficheiros não suportados ignorados: {names}.',
    'banner.unsupportedPresent': 'Existem tipos de ficheiro não suportados: {exts}.'
  });

  // Portuguese (Brazil)
  I18N['pt-BR'] && Object.assign(I18N['pt-BR'], {
    'banner.added': 'Adicionados {n} {files}.',
    'banner.doneOk': 'Concluído. {s} {files} convertidos.',
    'banner.finishedFail': 'Falharam {f} {files}.',
    'banner.finishedMixed': 'Concluído com erros: {s} {files} convertidos, {f} falharam.',
    'banner.noCommonFor': 'Sem conversão comum para: {exts}.',
    'banner.removedX': '{name} removido.',
    'banner.unsupportedAdded': 'Arquivos não compatíveis ignorados: {names}.',
    'banner.unsupportedPresent': 'Tipos de arquivo não compatíveis presentes: {exts}.'
  });

  // Russian
  I18N.ru && Object.assign(I18N.ru, {
    'banner.added': 'Добавлено {n} {files}.',
    'banner.doneOk': 'Готово. Конвертировано {s} {files}.',
    'banner.finishedFail': 'Не удалось {f} {files}.',
    'banner.finishedMixed': 'Завершено с ошибками: конвертировано {s} {files}, {f} сбоев.',
    'banner.noCommonFor': 'Нет общего формата конвертации для: {exts}.',
    'banner.removedX': 'Удалено: {name}.',
    'banner.unsupportedAdded': 'Неподдерживаемые файлы пропущены: {names}.',
    'banner.unsupportedPresent': 'Есть неподдерживаемые типы файлов: {exts}.'
  });

  // Turkish
  I18N.tr && Object.assign(I18N.tr, {
    'banner.added': '{n} {files} eklendi.',
    'banner.doneOk': 'Tamam. {s} {files} dönüştürüldü.',
    'banner.finishedFail': '{f} {files} başarısız oldu.',
    'banner.finishedMixed': 'Hatalarla tamamlandı: {s} {files} dönüştürüldü, {f} başarısız.',
    'banner.noCommonFor': 'Bu dosyalar için ortak bir dönüştürme yok: {exts}.',
    'banner.removedX': '{name} kaldırıldı.',
    'banner.unsupportedAdded': 'Desteklenmeyen dosyalar yok sayıldı: {names}.',
    'banner.unsupportedPresent': 'Desteklenmeyen dosya türleri mevcut: {exts}.'
  });

  // Ukrainian
  I18N.uk && Object.assign(I18N.uk, {
    'banner.added': 'Додано {n} {files}.',
    'banner.doneOk': 'Готово. Перетворено {s} {files}.',
    'banner.finishedFail': 'Не вдалося {f} {files}.',
    'banner.finishedMixed': 'Завершено з помилками: перетворено {s} {files}, збоїв {f}.',
    'banner.noCommonFor': 'Немає спільного формату перетворення для: {exts}.',
    'banner.removedX': 'Вилучено {name}.',
    'banner.unsupportedAdded': 'Непідтримувані файли пропущено: {names}.',
    'banner.unsupportedPresent': 'Є непідтримувані типи файлів: {exts}.'
  });

  // Chinese (Simplified)
  I18N['zh-CN'] && Object.assign(I18N['zh-CN'], {
    'banner.added': '已添加 {n} {files}。',
    'banner.doneOk': '完成。已转换 {s} {files}。',
    'banner.finishedFail': '{f} {files} 失败。',
    'banner.finishedMixed': '已完成但有错误：已转换 {s} {files}，{f} 个失败。',
    'banner.noCommonFor': '这些文件没有共同的可转换格式：{exts}。',
    'banner.removedX': '已移除 {name}。',
    'banner.unsupportedAdded': '已忽略不受支持的文件：{names}。',
    'banner.unsupportedPresent': '存在不受支持的文件类型：{exts}。'
  });


} catch (e) { /* I18N.en not found? ignore */ }

// Localized target dropdown override (groups + options)
(function () {
  function buildTargetsLocalized() {
    try {
      const targetFormat = window.targetFormat || document.querySelector('#targetFormat, select[name=target], select#target');
      const qualityWrap = window.qualityWrap || document.querySelector('#qualityWrap, .quality-wrap, [data-role="quality"]');
      if (!targetFormat || !qualityWrap) return;

      const groupsOrder = ['text', 'documents', 'spreadsheets', 'images', 'media'];
      const groupLabelKey = { text: 'group_text', documents: 'group_documents', spreadsheets: 'group_spreadsheets', images: 'group_images', media: 'group_media' };

      targetFormat.innerHTML = '';
      for (const key of groupsOrder) {
        if (!window.ENABLE_OUTPUTS || !window.ENABLE_OUTPUTS[key]) continue;
        const items = (window.TARGET_GROUPS && window.TARGET_GROUPS[key]) || null;
        if (!items) continue;

        const og = document.createElement('optgroup');
        og.label = (typeof t === 'function') ? t(groupLabelKey[key]) : key;

        items.forEach(([val]) => {
          const o = document.createElement('option');
          o.value = val;
          o.textContent = (typeof optLabel === 'function') ? optLabel(val) : (val.toUpperCase() + ' (.' + val + ')');
          og.appendChild(o);
        });

        targetFormat.appendChild(og);
      }

      // default to JPEG if present (for quality control)
      if ([...targetFormat.querySelectorAll('option')].some(o => o.value === 'jpeg')) {
        targetFormat.value = 'jpeg';
      }
      const v = targetFormat.value;
      qualityWrap.style.display = (v === 'jpeg' || v === 'webp') ? '' : 'none';
    } catch (e) { console.warn('i18n buildTargets failed:', e); }
  }
  window.buildTargets = buildTargetsLocalized;
  window.buildTargets = buildTargets;                // builds all groups/labels
  window.refreshTargetDropdown = refreshTargetDropdown; // filters to only valid targets

})();

/* I18N UI KEYS */
(function () {
  try {
    // English fallbacks
    I18N.en = I18N.en || {};
    Object.assign(I18N.en, {
      'ui.addFiles': 'Add files',
      'ui.saveAll': 'Save All',
      'ui.saveAllTitle': 'Save all outputs to a folder (if supported)'
    });

    // De
    if (I18N.de) Object.assign(I18N.de, {
      'ui.addFiles': 'Dateien hinzufügen',
      'ui.saveAll': 'Alles speichern',
      'ui.saveAllTitle': 'Alle Ausgaben in einen Ordner speichern (falls unterstützt)'
    });

    // Es
    if (I18N.es) Object.assign(I18N.es, {
      'ui.addFiles': 'Añadir archivos',
      'ui.saveAll': 'Guardar todo',
      'ui.saveAllTitle': 'Guardar todas las salidas en una carpeta (si es compatible)'
    });

    // Fr
    if (I18N.fr) Object.assign(I18N.fr, {
      'ui.addFiles': 'Ajouter des fichiers',
      'ui.saveAll': 'Tout enregistrer',
      'ui.saveAllTitle': 'Enregistrer toutes les sorties dans un dossier (si pris en charge)'
    });

    // It
    if (I18N.it) Object.assign(I18N.it, {
      'ui.addFiles': 'Aggiungi file',
      'ui.saveAll': 'Salva tutto',
      'ui.saveAllTitle': 'Salva tutte le uscite in una cartella (se supportato)'
    });

    // Pl
    if (I18N.pl) Object.assign(I18N.pl, {
      'ui.addFiles': 'Dodaj pliki',
      'ui.saveAll': 'Zapisz wszystko',
      'ui.saveAllTitle': 'Zapisz wszystkie wyniki do folderu (jeśli obsługiwane)'
    });

    // pt (Portugal)
    if (I18N.pt) Object.assign(I18N.pt, {
      'ui.addFiles': 'Adicionar ficheiros',
      'ui.saveAll': 'Guardar tudo',
      'ui.saveAllTitle': 'Guardar todas as saídas numa pasta (se suportado)'
    });

    // pt-BR
    if (I18N['pt-BR']) Object.assign(I18N['pt-BR'], {
      'ui.addFiles': 'Adicionar arquivos',
      'ui.saveAll': 'Salvar tudo',
      'ui.saveAllTitle': 'Salvar todas as saídas numa pasta (se suportado)'
    });

    // Ja
    if (I18N.ja) Object.assign(I18N.ja, {
      'ui.addFiles': 'ファイルを追加',
      'ui.saveAll': 'すべて保存',
      'ui.saveAllTitle': 'すべての出力をフォルダーに保存（対応している場合）'
    });

    // Ru
    if (I18N.ru) Object.assign(I18N.ru, {
      'ui.addFiles': 'Добавить файлы',
      'ui.saveAll': 'Сохранить всё',
      'ui.saveAllTitle': 'Сохранить все результаты в папку (если поддерживается)'
    });

    // zh-CN
    if (I18N['zh-CN']) Object.assign(I18N['zh-CN'], {
      'ui.addFiles': '添加文件',
      'ui.saveAll': '全部保存',
      'ui.saveAllTitle': '将所有输出保存到一个文件夹（若支持）'
    });

    // Ko
    if (I18N.ko) Object.assign(I18N.ko, {
      'ui.addFiles': '파일 추가',
      'ui.saveAll': '모두 저장',
      'ui.saveAllTitle': '모든 출력을 폴더에 저장(지원되는 경우)'
    });

    // Hi
    if (I18N.hi) Object.assign(I18N.hi, {
      'ui.addFiles': 'फ़ाइलें जोड़ें',
      'ui.saveAll': 'सब सेव करें',
      'ui.saveAllTitle': 'सभी आउटपुट एक फ़ोल्डर में सेव करें (यदि समर्थित)'
    });

    // Ar
    if (I18N.ar) Object.assign(I18N.ar, {
      'ui.addFiles': 'إضافة ملفات',
      'ui.saveAll': 'حفظ الكل',
      'ui.saveAllTitle': 'احفظ كل النواتج في مجلد (إن كان مدعومًا)'
    });

    // Uk
    if (I18N.uk) Object.assign(I18N.uk, {
      'ui.addFiles': 'Додати файли',
      'ui.saveAll': 'Зберегти все',
      'ui.saveAllTitle': 'Зберегти всі результати в папку (якщо підтримується)'
    });

    // Tr
    if (I18N.tr) Object.assign(I18N.tr, {
      'ui.addFiles': 'Dosya ekle',
      'ui.saveAll': 'Tümünü kaydet',
      'ui.saveAllTitle': 'Tüm çıktıları bir klasöre kaydet (destekleniyorsa)'
    });

    // Nl
    if (I18N.nl) Object.assign(I18N.nl, {
      'ui.addFiles': 'Bestanden toevoegen',
      'ui.saveAll': 'Alles opslaan',
      'ui.saveAllTitle': 'Sla alle uitvoer op in een map (indien ondersteund)'
    });
  } catch (e) { console.warn('i18n ui keys patch failed', e); }
})();




// === URL <-> target dropdown sync + quality toggle ===
function presetTargetFromURL() {
  try {
    var target = document.querySelector("#target-format, #targetFormat, select[name=target], select#target");
    var wrap = document.querySelector("#quality-wrap, #qualityWrap, .quality-wrap, [data-role='quality']");
    if (!target) return;

    var params = new URLSearchParams(location.search);
    var q = (params.get("to") || params.get("target") || "").toLowerCase();
    var alias = { jpg: "jpeg" };
    var wanted = alias[q] || q;

    if (!wanted) {
      var path = location.pathname.replace(/\/index\.html$/i, "");
      var seg = (path.split("/").filter(Boolean).pop() || "").toLowerCase();
      var m = seg.match(/([a-z0-9.]+)$/i);
      var cand = (m ? m[1] : "").replace(/\.$/, "");
      wanted = alias[cand] || cand;
    }

    if (wanted && target.querySelector('option[value="' + wanted + '"]')) {
      target.value = wanted;
    }
    if (wrap) wrap.style.display = (target.value === "jpeg" || target.value === "webp") ? "" : "none";
  } catch (e) { }
}

(function () {
  function $(s) { return document.querySelector(s); }

  function applyQualityVisibility() {
    var t = $("#target-format, #targetFormat, select[name=target], select#target");
    var w = $("#quality-wrap, #qualityWrap, .quality-wrap, [data-role='quality']");
    if (!t || !w) return;
    w.style.display = (t.value === "jpeg" || t.value === "webp") ? "" : "none";
  }

  document.addEventListener("change", function (ev) {
    var el = ev.target;
    if (!el || el.tagName !== "SELECT") return;
    if (el.matches("#target-format, #targetFormat, select[name=target], select#target")) {
      try {
        var u = new URL(location.href);
        u.searchParams.set("to", el.value);
        history.replaceState(null, "", u.toString());
      } catch (e) { }
      applyQualityVisibility();
    }
  });

  document.addEventListener("DOMContentLoaded", function () {
    try { presetTargetFromURL(); } catch (e) { }
    applyQualityVisibility();
  });
})();






