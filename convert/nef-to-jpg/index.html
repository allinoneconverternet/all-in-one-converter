<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Redirecting…</title>
  
  
  <script>try{location.replace('/en/?to=jpeg');}catch(e){location.href='/en/?to=jpeg';}</script>



<!-- icons start -->
<link rel="icon" href="/favicon.ico" sizes="any">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="manifest" href="/site.webmanifest">
<!-- icons end -->

<meta name="robots" content="index,follow" />
<link rel="canonical" href="https://www.all-in-one-converter.netconvert/nef-to-jpg/" />

<script defer src="/js/vendor/pdfjs/pdf.min.js"></script>
<script>window.pdfjsLib && (pdfjsLib.GlobalWorkerOptions.workerSrc="/js/vendor/pdfjs/pdf.worker.min.js");</script>
</head>
<body>
  <p>Redirecting to <a href="/en/?to=jpeg">/en/?to=jpeg</a>…</p>
  <!-- Surgeon Pointer -->
<script defer src="/vendor/ffmpeg/app.ffmpeg-loader.js"></script>
<p style="margin-top:1rem"><a href="/en/?to=jpeg">Open the converter</a></p>

<script>
(() => {
  const picker = document.querySelector(".file-picker");
  if (!picker) return;

  const input = document.getElementById("file-input");
  const btn   = document.getElementById("file-btn");
  const label = document.getElementById("file-label");

  picker.classList.add("js-ready");

  const T_CHOOSE   = picker.dataset.i18nChoose   || "Choose files";
  const T_NOFILE   = picker.dataset.i18nNoFile   || "No file chosen";
  const T_MULTIPLE = picker.dataset.i18nMultiple || "{n} files selected";

  const LEFT_PREF = Math.max(1, parseInt(picker.dataset.leftPref || "10", 10));
  const TAIL_MIN  = Math.max(0, parseInt(picker.dataset.tailMin  || "5", 10));
  const ALWAYS    = String(picker.dataset.alwaysEllipsis || "").toLowerCase() === "true";

  btn.textContent   = T_CHOOSE;
  label.textContent = T_NOFILE;

  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  function setCtxFontFrom(el) {
    const cs = getComputedStyle(el);
    ctx.font = [cs.fontStyle, cs.fontVariant, cs.fontWeight, cs.fontStretch, cs.fontSize, cs.fontFamily]
      .filter(Boolean).join(" ");
    const ls = parseFloat(cs.letterSpacing);
    ctx._ls = isNaN(ls) ? 0 : ls;
  }
  function measure(text) {
    const w = ctx.measureText(text).width;
    return w + (ctx._ls ? ctx._ls * Math.max(0, text.length - 1) : 0);
  }

  function formatMiddle(filename, el, leftPref, tailMin) {
    setCtxFontFrom(el);
    const maxW = Math.max(0, (el.clientWidth || el.offsetWidth || 0) - 2);
    if (!maxW) return filename;

    const dot = filename.lastIndexOf(".");
    const ext  = dot > 0 ? filename.slice(dot) : "";
    const base = dot > 0 ? filename.slice(0, dot) : filename;

    if (!ALWAYS && measure(filename) <= maxW) return filename;

    let rk = Math.min(Math.max(tailMin, 0), base.length);
    let lk = Math.min(Math.max(LEFT_PREF, 1), Math.max(1, base.length - rk));
    const build = (L, R) => base.slice(0, L) + "…" + base.slice(base.length - R) + ext;

    let out = build(lk, rk);
    while (measure(out) > maxW && (lk > 1 || rk > tailMin)) {
      if (lk > 1) lk--;
      else if (rk > tailMin) rk--;
      out = build(lk, rk);
    }
    if (measure(out) > maxW) {
      let e = ext;
      out = "…" + e;
      while (measure(out) > maxW && e.length) {
        e = e.slice(0, -1);
        out = "…" + e;
      }
    }
    return out;
  }

  let lastFullName = null;
  function render() {
    const fs = input.files;
    if (!fs || fs.length === 0) {
      label.textContent = T_NOFILE;
      label.removeAttribute("title");
      picker.classList.remove("has-files");
      lastFullName = null;
      return;
    }
    picker.classList.add("has-files");

    if (fs.length === 1) {
      lastFullName = fs[0].name;
      label.textContent = formatMiddle(lastFullName, label, LEFT_PREF, TAIL_MIN);
      label.title = lastFullName;
    } else {
      lastFullName = null;
      label.textContent = T_MULTIPLE.replace("{n}", fs.length);
      label.title = Array.from(fs).map(f => f.name).join("\n");
    }
  }

  btn.addEventListener("click", () => input.click());
  picker.addEventListener("click", (e) => { if (e.target !== btn && e.target !== input) input.click(); });
  input.addEventListener("change", render);

  const ro = new ResizeObserver(() => {
    if (lastFullName) label.textContent = formatMiddle(lastFullName, label, LEFT_PREF, TAIL_MIN);
  });
  ro.observe(label);
  window.addEventListener("resize", () => {
    if (lastFullName) label.textContent = formatMiddle(lastFullName, label, LEFT_PREF, TAIL_MIN);
  });
  if (document.fonts && document.fonts.ready) {
    document.fonts.ready.then(() => {
      if (lastFullName) label.textContent = formatMiddle(lastFullName, label, LEFT_PREF, TAIL_MIN);
    });
  }
  render();
})();
</script>
</body>
</html>










